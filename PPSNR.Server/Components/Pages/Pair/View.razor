@page "/{pairId:guid}/view/{token:guid}"
@layout EmptyLayout
@rendermode InteractiveServer
@using PPSNR.Server.Components.Layout
@using PPSNR.Server.Data.Entities
@using System.Threading
@inject IDbContextFactory<ApplicationDbContext> DbFactory
@inject NavigationManager Nav
@inject Services.ImagesCacheService ImagesCache
@inject IJSRuntime JS

<script src="js/retry-policy.js"></script>
<script src="js/hub-reconnect.js"></script>


@* Styles moved to wwwroot/app.scss *@

<div id="canvas">
    @foreach (var s in _slots)
    {
        // Render when borders are on OR when placement is visible and an image is present (local or external)
        if (_placements.TryGetValue((s.Id, _viewProfile), out var p) && (_showBorders || (p.Visible && !string.IsNullOrEmpty(s.ImageUrl))))
        {
            <img class="@($"slot-img{(_showBorders ? " slot-outline" : string.Empty)}")"
                 src="@s.ImageUrl"
                 style="left:@(p.X)px; top:@(p.Y)px; z-index:@p.ZIndex;"
                 width="@(p.Width ?? GetWidth(s))"
                 height="@(p.Height ?? GetHeight(s))"/>
        }
    }
    
</div>

@code {
    [Parameter] public Guid PairId { get; set; }
    [Parameter] public Guid Token { get; set; }

    private StreamerPair? _pair;
    private List<Layout> _layouts = new();
    private List<Slot> _slots = new();
    // Store placements for both profiles, keyed by (SlotId, Profile)
    private Dictionary<(Guid, SlotProfile), SlotPlacement> _placements = new();
    private HubConnection? _hub;
    private bool _authorized;
    private SlotProfile _viewProfile;
    private bool _showBorders;
    private bool _jsReady; // set when first interactive render completes
    private bool _keepModalPinned;
    private Timer? _serverProbeTimer;
    private bool _isServerReachable;

    protected override async Task OnInitializedAsync()
    {
        // Validate token: accept either OwnerViewToken (owner view) or ViewToken (partner view)
        await using var dbInit = await DbFactory.CreateDbContextAsync();
        var link = dbInit.PairLinks.FirstOrDefault(l => l.PairId == PairId);
        if (link != null && (link.ExpiresAt == null || link.ExpiresAt > DateTime.UtcNow))
        {
            if (link.OwnerViewToken == Token)
            {
                _authorized = true;
                _viewProfile = SlotProfile.Owner;
            }
            else if (link.ViewToken == Token)
            {
                _authorized = true;
                _viewProfile = SlotProfile.Partner;
            }
            else
            {
                _authorized = false;
            }
        }
        else
        {
            _authorized = false;
        }
        if (!_authorized)
        {
            Nav.NavigateTo("/403", forceLoad: true);
            return;
        }

        _pair = dbInit.Pairs.FirstOrDefault(p => p.Id == PairId);
        if (_pair == null) return;
        _layouts = dbInit.Layouts.Where(l => l.PairId == PairId).ToList();
        var layoutIds = _layouts.Select(l => l.Id).ToList();
        _slots = dbInit.Slots.Where(s => layoutIds.Contains(s.LayoutId))
                         .OrderBy(s => s.ZIndex)
                         .ToList();

        // Load placements for BOTH profiles so we can render both viewers' Pokémon simultaneously
        var slotIds = _slots.Select(sl => sl.Id).ToList();
        _placements = dbInit.SlotPlacements
            .Where(sp => slotIds.Contains(sp.SlotId))
            .ToDictionary(sp => (sp.SlotId, sp.Profile), sp => sp);

        // Normalize any legacy or external ImageUrl values so images render
        await NormalizeSlotImagesAsync(_slots);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && _authorized && _hub == null)
        {
            // JS is available once we reach OnAfterRenderAsync; mark ready before setup
            _jsReady = true;

            await SetupHubAsync();
        }
    }

    private async Task SetupHubAsync()
    {
        try
        {
            _keepModalPinned = false;
            _isServerReachable = true;

            _hub = new HubConnectionBuilder()
                .WithUrl(Nav.ToAbsoluteUri("/hubs/layout"))
                .WithAutomaticReconnect(new Shared.SignalR.AdvancedRetryPolicy())
                .Build();

            // Typed envelope handler for forward-compatible messages
            _hub.On<PPSNR.Shared.SignalR.SignalRMessageEnvelope>("Message", envelope =>
            {
                try
                {
                    if (envelope == null) return;
                    if (string.Equals(envelope.Type, "SlotUpdated", StringComparison.OrdinalIgnoreCase) && envelope.Data.HasValue)
                    {
                        var dto = System.Text.Json.JsonSerializer.Deserialize<PPSNR.Shared.SignalR.SlotUpdatedDto>(envelope.Data.Value.GetRawText());
                        if (dto == null) return;

                        var id = dto.Id;
                        var profile = dto.Profile;
                        var x = dto.X;
                        var y = dto.Y;
                        var z = dto.ZIndex;
                        var vis = dto.Visible;
                        var img = dto.ImageUrl;
                        var width = dto.Width;
                        var height = dto.Height;

                        var slot = _slots.FirstOrDefault(s => s.Id == id);
                        if (slot != null)
                        {
                            // Apply image update even when null to support clearing from Select page
                            slot.ImageUrl = img;
                            if (width.HasValue) slot.Width = width.Value;
                            if (height.HasValue) slot.Height = height.Value;
                            if (profile != null)
                            {
                                var prof = (SlotProfile)profile.Value;
                                if (_placements.TryGetValue((slot.Id, prof), out var placement))
                                {
                                    if (x.HasValue) placement.X = x.Value;
                                    if (y.HasValue) placement.Y = y.Value;
                                    if (z.HasValue) placement.ZIndex = z.Value;
                                    if (vis.HasValue) placement.Visible = vis.Value;
                                    if (width.HasValue) placement.Width = width.Value;
                                    if (height.HasValue) placement.Height = height.Value;
                                }
                            }
                            InvokeAsync(StateHasChanged);
                        }
                    }
                    else if (string.Equals(envelope.Type, "PlacementsReset", StringComparison.OrdinalIgnoreCase))
                    {
                        InvokeAsync(async () =>
                        {
                            await ReloadPlacementsAsync();
                            StateHasChanged();
                        });
                    }
                    else if (string.Equals(envelope.Type, "ToggleBorders", StringComparison.OrdinalIgnoreCase) && envelope.Data.HasValue)
                    {
                        try
                        {
                            var root = envelope.Data.Value;
                            if (root.TryGetProperty("show", out var s) && (s.ValueKind == System.Text.Json.JsonValueKind.True || s.ValueKind == System.Text.Json.JsonValueKind.False))
                            {
                                var value = s.GetBoolean();
                                InvokeAsync(() => { _showBorders = value; StateHasChanged(); });
                            }
                        }
                        catch { /* ignore */ }
                    }
                }
                catch { /* ignore malformed event */ }
            });

            _hub.Reconnecting += async (error) =>
            {
                try
                {
                    _keepModalPinned = true;

                    await JS.InvokeVoidAsync("console.warn", "[View.razor] Hub reconnecting...", error?.Message);
                    await JS.InvokeVoidAsync("PPSNR.triggerReconnectModalState", "retrying");
                    await JS.InvokeVoidAsync("PPSNR.setReconnectOverlayForced", true);
                }
                catch { /* ignore */ }
            };

            _hub.Reconnected += async (connectionId) =>
            {
                try
                {
                    _keepModalPinned = false;

                    await JS.InvokeVoidAsync("console.log", $"[View.razor] Hub reconnected. ConnectionId={connectionId}");
                    await JS.InvokeVoidAsync("PPSNR.triggerReconnectModalState", "hide");
                    await JS.InvokeVoidAsync("PPSNR.resetRetryPolicy");
                    await JS.InvokeVoidAsync("PPSNR.setReconnectOverlayForced", false);
                }
                catch { /* ignore */ }

                // Rejoin pair group because SignalR subscriptions reset after reconnect
                try
                {
                    await _hub.SendAsync("SubscribeToPair", PairId.ToString());
                }
                catch (Exception sendEx)
                {
                    await JS.InvokeVoidAsync("console.error", $"[View.razor] Failed to resubscribe after reconnect: {sendEx.Message}");
                }
            };

            // When hub closes, attempt graceful reconnection without page reload
            _hub.Closed += async (error) =>
            {
                try
                {
                    _keepModalPinned = true;

                    // Log the disconnection for debugging
                    if (error != null)
                    {
                        await JS.InvokeVoidAsync("console.warn", $"[View.razor] Hub disconnected: {error.Message}");
                    }
                    else
                    {
                        await JS.InvokeVoidAsync("console.log", "[View.razor] Hub disconnected");
                    }

                    // Show the reconnect modal manually since this is a hub disconnect, not a Blazor circuit failure
                    try
                    {
                        await JS.InvokeVoidAsync("PPSNR.triggerReconnectModalState", "failed");
                    }
                    catch { /* modal may not be available in OBS context */ }

                    // Wait for Blazor's reconnect UI to finish (up to 2 minutes)
                    await JS.InvokeVoidAsync("console.debug", "[View.razor] Waiting for Blazor UI...");
                    try
                    {
                        await JS.InvokeVoidAsync("PPSNR.waitForBlazorReconnect");
                    }
                    catch { /* ignore */ }

                    // Get the next retry delay from the shared retry policy
                    var retryDelayMs = await GetNextRetryDelayAsync();
                    if (retryDelayMs.HasValue && retryDelayMs.Value > 0)
                    {
                        await JS.InvokeVoidAsync("console.debug", $"[View.razor] Retrying hub connection in {retryDelayMs}ms");
                        await Task.Delay(retryDelayMs.Value);
                    }
                    else
                    {
                        // If retry policy says we're done, just wait a bit before trying
                        await Task.Delay(500);
                    }

                    if (_hub != null)
                    {
                        await _hub.DisposeAsync();
                        _hub = null;
                    }

                    if (_serverProbeTimer == null)
                    {
                        _serverProbeTimer = new Timer(async _ => await PollServerAvailabilityAsync(), null, 0, 3000);
                    }

                    if (!_isServerReachable)
                    {
                        await JS.InvokeVoidAsync("console.debug", "[View.razor] Server still offline, delaying hub rebuild");
                        await Task.Delay(2000);
                        return;
                    }

                    await SetupHubAsync();
                }
                catch (Exception ex)
                {
                    // Log error
                    try
                    {
                        await JS.InvokeVoidAsync("console.error", $"[View.razor] Hub reconnection error: {ex.Message}");
                    }
                    catch { /* ignore */ }

                    // Schedule another attempt after a delay
                    await Task.Delay(2000);
                    try
                    {
                        if (_hub != null)
                        {
                            await _hub.DisposeAsync();
                            _hub = null;
                        }
                        await SetupHubAsync();
                    }
                    catch { /* If this also fails, let the next Closed event handle it */ }
                }
            };

            await _hub.StartAsync();
            _keepModalPinned = false;
            await JS.InvokeVoidAsync("PPSNR.releaseReconnectOverlay");
            await JS.InvokeVoidAsync("PPSNR.setReconnectOverlayForced", false);

            await JS.InvokeVoidAsync("console.log", "[View.razor] Hub connected successfully");
            await JS.InvokeVoidAsync("PPSNR.triggerReconnectModalState", "hide");

            // Reset retry policy on successful connection
            try
            {
                await JS.InvokeVoidAsync("PPSNR.resetRetryPolicy");
            }
            catch { }

            await _hub.SendAsync("SubscribeToPair", PairId.ToString());
        }
        catch (Exception ex)
        {
            try
            {
                await JS.InvokeVoidAsync("console.error", $"[View.razor] SetupHubAsync error: {ex.Message}");
            }
            catch { /* ignore */ }
            throw;
        }
    }

    /// <summary>
    /// Gets the next retry delay from the shared JavaScript retry policy
    /// </summary>
    private async Task<int?> GetNextRetryDelayAsync()
    {
        try
        {
            // Use a helper method to get the next delay
            var delay = await JS.InvokeAsync<int?>("PPSNR.getNextRetryDelayHelper");
            return delay ?? 3000;
        }
        catch (Exception ex)
        {
            // Fallback to fixed delay if retry policy is not available
            try
            {
                await JS.InvokeVoidAsync("console.warn", $"[View.razor] Failed to get retry delay: {ex.Message}");
            }
            catch { }
            return 3000; // 3 second fallback
        }
    }

    private async Task PollServerAvailabilityAsync()
    {
        try
        {
            var reachable = await JS.InvokeAsync<bool>("PPSNR.isServerReachable");
            _isServerReachable = reachable;
            if (reachable)
            {
                await JS.InvokeVoidAsync("console.debug", "[View.razor] Server reachable again");
                _serverProbeTimer?.Change(Timeout.Infinite, Timeout.Infinite);
                _serverProbeTimer?.Dispose();
                _serverProbeTimer = null;
            }
        }
        catch
        {
            _isServerReachable = false;
        }
    }

    public void Dispose()
    {
        _ = _hub?.DisposeAsync();
    }

    private async Task NormalizeSlotImagesAsync(IEnumerable<Slot> list)
    {
        var changed = false;
        foreach (var s in list)
        {
            if (!string.IsNullOrWhiteSpace(s.ImageUrl))
            {
                var url = s.ImageUrl!;
                if (!url.StartsWith("/"))
                {
                    try
                    {
                        var normalized = await ImagesCache.GetCachedImageUrlAsync(url);
                        if (!string.Equals(normalized, url, StringComparison.Ordinal))
                        {
                            s.ImageUrl = normalized;
                            changed = true;
                        }
                    }
                    catch
                    {
                        // ignore and keep original
                    }
                }
            }
        }
        if (changed)
        {
            await using var db = await DbFactory.CreateDbContextAsync();
            // Attach and update only changed slots
            foreach (var s in list.Where(x => !string.IsNullOrWhiteSpace(x.ImageUrl)))
            {
                db.Attach(s);
                db.Entry(s).Property(x => x.ImageUrl).IsModified = true;
            }
            await db.SaveChangesAsync();
        }
    }
}

@code {
    private async Task ReloadPlacementsAsync()
    {
        try
        {
            await using var db = await DbFactory.CreateDbContextAsync();
            var slotIds = _slots.Select(sl => sl.Id).ToList();
            _placements = db.SlotPlacements
                .Where(sp => slotIds.Contains(sp.SlotId))
                .ToDictionary(sp => (sp.SlotId, sp.Profile), sp => sp);
            await Task.CompletedTask;
        }
        catch
        {
            // ignore reload errors
        }
    }
    private static string GetSizeStyle(Slot s)
    {
        var w = s.Width;
        var h = s.Height;
        var style = string.Empty;
        if (w != null) style += $" width:{w}px;";
        if (h != null) style += $" height:{h}px;";
        return style;
    }

    private static int? GetWidth(Slot s) => s.Width;
    private static int? GetHeight(Slot s) => s.Height;

    // Removed legacy AdditionalProperties helpers; sizes are explicit now
}
