@page "/{pairId:guid}/view/{token:guid}"
@layout EmptyLayout
@rendermode InteractiveServer
@using System.Collections.Generic
@using PPSNR.Server.Components.Layout
@using Microsoft.EntityFrameworkCore
@using PPSNR.Server.Data.Entities
@inject IDbContextFactory<ApplicationDbContext> DbFactory
@inject NavigationManager Nav
@inject PPSNR.Server.Services.ImagesCacheService ImagesCache


<style>
    html, body, #app { background: transparent; margin: 0; padding: 0; }
    #canvas { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
    .slot-img { position: absolute; image-rendering: auto; }
</style>

<div id="canvas">
    @foreach (var s in _slots)
    {
        // Render positions based on the VIEWER's profile placement (Owner or Partner)
        // for all slots. This ensures Owner sees/edits Owner placements for both
        // Owner and Partner Pokémon, and Partner sees/edits Partner placements.
        if (_placements.TryGetValue((s.Id, _viewProfile), out var p) && p.Visible && !string.IsNullOrEmpty(s.ImageUrl))
        {
            <img class="slot-img"
                 src="@s.ImageUrl"
                 style="left:@(p.X)px; top:@(p.Y)px; z-index:@p.ZIndex;"
                 width="@(p.Width ?? GetWidth(s))"
                 height="@(p.Height ?? GetHeight(s))"
                 alt="slot"/>
        }
    }
    
</div>

@code {
    [Parameter] public Guid PairId { get; set; }
    [Parameter] public Guid Token { get; set; }

    private StreamerPair? _pair;
    private List<Layout> _layouts = new();
    private List<Slot> _slots = new();
    // Store placements for both profiles, keyed by (SlotId, Profile)
    private Dictionary<(Guid, SlotProfile), SlotPlacement> _placements = new();
    private HubConnection? _hub;
    private bool _authorized;
    private SlotProfile _viewProfile;

    protected override async Task OnInitializedAsync()
    {
        // Validate token: accept either OwnerViewToken (owner view) or ViewToken (partner view)
        await using var dbInit = await DbFactory.CreateDbContextAsync();
        var link = dbInit.PairLinks.FirstOrDefault(l => l.PairId == PairId);
        if (link != null && (link.ExpiresAt == null || link.ExpiresAt > DateTime.UtcNow))
        {
            if (link.OwnerViewToken == Token)
            {
                _authorized = true;
                _viewProfile = SlotProfile.Owner;
            }
            else if (link.ViewToken == Token)
            {
                _authorized = true;
                _viewProfile = SlotProfile.Partner;
            }
            else
            {
                _authorized = false;
            }
        }
        else
        {
            _authorized = false;
        }
        if (!_authorized)
        {
            Nav.NavigateTo("/403", forceLoad: true);
            return;
        }

        _pair = dbInit.Pairs.FirstOrDefault(p => p.Id == PairId);
        if (_pair == null) return;
        _layouts = dbInit.Layouts.Where(l => l.PairId == PairId).ToList();
        var layoutIds = _layouts.Select(l => l.Id).ToList();
        _slots = dbInit.Slots.Where(s => layoutIds.Contains(s.LayoutId))
                         .OrderBy(s => s.ZIndex)
                         .ToList();

        // Load placements for BOTH profiles so we can render both viewers' Pokémon simultaneously
        var slotIds = _slots.Select(sl => sl.Id).ToList();
        _placements = dbInit.SlotPlacements
            .Where(sp => slotIds.Contains(sp.SlotId))
            .ToDictionary(sp => (sp.SlotId, sp.Profile), sp => sp);

        // Normalize any legacy or external ImageUrl values so images render
        await NormalizeSlotImagesAsync(_slots);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && _authorized && _hub == null)
        {
            _hub = new HubConnectionBuilder().WithUrl(Nav.ToAbsoluteUri("/hubs/layout")).WithAutomaticReconnect().Build();
            _hub.On<object>("SlotUpdated", payload =>
            {
                try
                {
                    Guid id;
                    string? img = null;
                    bool imgPresent = false;
                    int? profile = null;
                    float? x = null;
                    float? y = null;
                    int? z = null;
                    bool? vis = null;
                    string? add = null;
                    bool addPresent = false;

                    if (payload is System.Text.Json.JsonElement el)
                    {
                        if (!TryGetPropertyCI(el, "Id", out var idProp)) return;
                        id = idProp.GetGuid();
                        if (TryGetPropertyCI(el, "ImageUrl", out var imgProp)) { imgPresent = true; img = imgProp.ValueKind == System.Text.Json.JsonValueKind.Null ? null : imgProp.GetString(); }
                        if (TryGetPropertyCI(el, "Profile", out var pr)) profile = pr.GetInt32();
                        if (TryGetPropertyCI(el, "X", out var xProp)) x = (float)xProp.GetDouble();
                        if (TryGetPropertyCI(el, "Y", out var yProp)) y = (float)yProp.GetDouble();
                        if (TryGetPropertyCI(el, "ZIndex", out var zProp)) z = zProp.GetInt32();
                        if (TryGetPropertyCI(el, "Visible", out var vProp)) vis = vProp.GetBoolean();
                        if (TryGetPropertyCI(el, "AdditionalProperties", out var addProp)) { addPresent = true; add = addProp.ValueKind == System.Text.Json.JsonValueKind.Null ? null : addProp.GetString(); }
                    }
                    else if (payload is IDictionary<string, object> dict)
                    {
                        if (!TryGetValueCI(dict, "Id", out var idObj) || idObj is null || !Guid.TryParse(idObj.ToString(), out id)) return;
                        if (TryGetValueCI(dict, "ImageUrl", out var iObj)) { imgPresent = true; img = iObj == null ? null : iObj.ToString(); }
                        if (TryGetValueCI(dict, "Profile", out var pObj) && int.TryParse(pObj?.ToString(), out var pv)) profile = pv;
                        if (TryGetValueCI(dict, "X", out var xObj) && float.TryParse(xObj?.ToString(), out var xv)) x = xv;
                        if (TryGetValueCI(dict, "Y", out var yObj) && float.TryParse(yObj?.ToString(), out var yv)) y = yv;
                        if (TryGetValueCI(dict, "ZIndex", out var zObj) && int.TryParse(zObj?.ToString(), out var zv)) z = zv;
                        if (TryGetValueCI(dict, "Visible", out var vObj) && bool.TryParse(vObj?.ToString(), out var vv)) vis = vv;
                        if (TryGetValueCI(dict, "AdditionalProperties", out var aObj)) { addPresent = true; add = aObj == null ? null : aObj.ToString(); }
                    }
                    else
                    {
                        var json = System.Text.Json.JsonDocument.Parse(System.Text.Json.JsonSerializer.Serialize(payload));
                        if (!TryGetPropertyCI(json.RootElement, "Id", out var idProp)) return;
                        id = idProp.GetGuid();
                        if (TryGetPropertyCI(json.RootElement, "ImageUrl", out var imgProp)) { imgPresent = true; img = imgProp.ValueKind == System.Text.Json.JsonValueKind.Null ? null : imgProp.GetString(); }
                        if (TryGetPropertyCI(json.RootElement, "Profile", out var pr)) profile = pr.GetInt32();
                        if (TryGetPropertyCI(json.RootElement, "X", out var xProp)) x = (float)xProp.GetDouble();
                        if (TryGetPropertyCI(json.RootElement, "Y", out var yProp)) y = (float)yProp.GetDouble();
                        if (TryGetPropertyCI(json.RootElement, "ZIndex", out var zProp)) z = zProp.GetInt32();
                        if (TryGetPropertyCI(json.RootElement, "Visible", out var vProp)) vis = vProp.GetBoolean();
                        if (TryGetPropertyCI(json.RootElement, "AdditionalProperties", out var addProp)) { addPresent = true; add = addProp.ValueKind == System.Text.Json.JsonValueKind.Null ? null : addProp.GetString(); }
                    }

                    var slot = _slots.FirstOrDefault(s => s.Id == id);
                    if (slot != null)
                    {
                        if (imgPresent) slot.ImageUrl = img;
                        if (addPresent) slot.AdditionalProperties = add;
                        // Apply placement updates to the placement that matches the payload profile
                        if (profile != null)
                        {
                            var prof = (SlotProfile)profile.Value;
                            if (_placements.TryGetValue((slot.Id, prof), out var placement))
                            {
                                if (x != null) placement.X = x.Value;
                                if (y != null) placement.Y = y.Value;
                                if (z != null) placement.ZIndex = z.Value;
                                if (vis != null) placement.Visible = vis.Value;
                                if (addPresent)
                                {
                                    var (w, h) = GetSizeFromAdditional(slot);
                                    placement.Width = w;
                                    placement.Height = h;
                                }
                            }
                        }
                        InvokeAsync(StateHasChanged);
                    }
                }
                catch
                {
                    // ignore malformed event
                }
            });
            // React to bulk reset events (no payload). Reload placements from DB and re-render.
            _hub.On("PlacementsReset", () =>
            {
                try
                {
                    InvokeAsync(async () =>
                    {
                        await ReloadPlacementsAsync();
                        StateHasChanged();
                    });
                }
                catch { /* ignore */ }
            });
            await _hub.StartAsync();
            await _hub.SendAsync("SubscribeToPair", PairId.ToString());
        }
    }

    public void Dispose()
    {
        _ = _hub?.DisposeAsync();
    }

    private async Task NormalizeSlotImagesAsync(IEnumerable<Slot> list)
    {
        var changed = false;
        foreach (var s in list)
        {
            if (!string.IsNullOrWhiteSpace(s.ImageUrl))
            {
                var url = s.ImageUrl!;
                if (!url.StartsWith("/"))
                {
                    try
                    {
                        var normalized = await ImagesCache.GetCachedImageUrlAsync(url);
                        if (!string.Equals(normalized, url, StringComparison.Ordinal))
                        {
                            s.ImageUrl = normalized;
                            changed = true;
                        }
                    }
                    catch
                    {
                        // ignore and keep original
                    }
                }
            }
        }
        if (changed)
        {
            await using var db = await DbFactory.CreateDbContextAsync();
            // Attach and update only changed slots
            foreach (var s in list.Where(x => !string.IsNullOrWhiteSpace(x.ImageUrl)))
            {
                db.Attach(s);
                db.Entry(s).Property(x => x.ImageUrl).IsModified = true;
            }
            await db.SaveChangesAsync();
        }
    }
}

@code {
    private async Task ReloadPlacementsAsync()
    {
        try
        {
            await using var db = await DbFactory.CreateDbContextAsync();
            var slotIds = _slots.Select(sl => sl.Id).ToList();
            _placements = db.SlotPlacements
                .Where(sp => slotIds.Contains(sp.SlotId))
                .ToDictionary(sp => (sp.SlotId, sp.Profile), sp => sp);
            await Task.CompletedTask;
        }
        catch
        {
            // ignore reload errors
        }
    }
    private static string GetSizeStyle(Slot s)
    {
        var (w, h) = GetSizeFromAdditional(s);
        var style = string.Empty;
        if (w != null) style += $" width:{w}px;";
        if (h != null) style += $" height:{h}px;";
        return style;
    }

    private static (int? w, int? h) GetSizeFromAdditional(Slot s)
    {
        try
        {
            if (string.IsNullOrWhiteSpace(s.AdditionalProperties)) return (null, null);
            using var doc = System.Text.Json.JsonDocument.Parse(s.AdditionalProperties);
            var root = doc.RootElement;
            int? w = null, h = null;
            if (TryGetPropertyCI(root, "w", out var wProp) && wProp.ValueKind == System.Text.Json.JsonValueKind.Number)
            {
                var v = (int)wProp.GetDouble();
                if (v > 0) w = v;
            }
            if (TryGetPropertyCI(root, "h", out var hProp) && hProp.ValueKind == System.Text.Json.JsonValueKind.Number)
            {
                var v = (int)hProp.GetDouble();
                if (v > 0) h = v;
            }
            return (w, h);
        }
        catch
        {
            return (null, null);
        }
    }

    private static int? GetWidth(Slot s)
    {
        var (w, _) = GetSizeFromAdditional(s);
        return w;
    }
    private static int? GetHeight(Slot s)
    {
        var (_, h) = GetSizeFromAdditional(s);
        return h;
    }

    private static bool TryGetPropertyCI(System.Text.Json.JsonElement el, string name, out System.Text.Json.JsonElement prop)
    {
        if (el.TryGetProperty(name, out prop)) return true;
        var camel = LowerFirst(name);
        return el.TryGetProperty(camel, out prop);
    }
    private static bool TryGetValueCI(IDictionary<string, object> dict, string name, out object? value)
    {
        if (dict.TryGetValue(name, out value)) return true;
        var camel = LowerFirst(name);
        return dict.TryGetValue(camel, out value);
    }
    private static string LowerFirst(string s)
        => string.IsNullOrEmpty(s) ? s : char.ToLowerInvariant(s[0]) + s.Substring(1);
}
