@page "/{pairId:guid}/view/{token:guid}"
@layout EmptyLayout
@rendermode InteractiveServer
@using PPSNR.Server.Components.Layout
@using PPSNR.Server.Data.Entities
@inject IDbContextFactory<ApplicationDbContext> DbFactory
@inject NavigationManager Nav
@inject Services.ImagesCacheService ImagesCache


<style>
    html, body, #app { background: transparent; margin: 0; padding: 0; }
    #canvas { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
    .slot-img { position: absolute; image-rendering: auto; }
    .slot-outline { outline: 2px dashed rgba(0, 150, 255, 0.8); outline-offset: -1px; }
</style>

<div id="canvas">
    @foreach (var s in _slots)
    {
        if (_placements.TryGetValue((s.Id, _viewProfile), out var p) && (_showBorders || (p.Visible && !string.IsNullOrEmpty(s.ImageUrl) && s.ImageUrl[0] == '/')))
        {
            <img class="@($"slot-img{(_showBorders ? " slot-outline" : string.Empty)}")"
                 src="@s.ImageUrl"
                 style="left:@(p.X)px; top:@(p.Y)px; z-index:@p.ZIndex;"
                 width="@(p.Width ?? GetWidth(s))"
                 height="@(p.Height ?? GetHeight(s))"/>
        }
    }
    
</div>

@code {
    [Parameter] public Guid PairId { get; set; }
    [Parameter] public Guid Token { get; set; }

    private StreamerPair? _pair;
    private List<Layout> _layouts = new();
    private List<Slot> _slots = new();
    // Store placements for both profiles, keyed by (SlotId, Profile)
    private Dictionary<(Guid, SlotProfile), SlotPlacement> _placements = new();
    private HubConnection? _hub;
    private bool _authorized;
    private SlotProfile _viewProfile;
    private bool _showBorders;

    protected override async Task OnInitializedAsync()
    {
        // Validate token: accept either OwnerViewToken (owner view) or ViewToken (partner view)
        await using var dbInit = await DbFactory.CreateDbContextAsync();
        var link = dbInit.PairLinks.FirstOrDefault(l => l.PairId == PairId);
        if (link != null && (link.ExpiresAt == null || link.ExpiresAt > DateTime.UtcNow))
        {
            if (link.OwnerViewToken == Token)
            {
                _authorized = true;
                _viewProfile = SlotProfile.Owner;
            }
            else if (link.ViewToken == Token)
            {
                _authorized = true;
                _viewProfile = SlotProfile.Partner;
            }
            else
            {
                _authorized = false;
            }
        }
        else
        {
            _authorized = false;
        }
        if (!_authorized)
        {
            Nav.NavigateTo("/403", forceLoad: true);
            return;
        }

        _pair = dbInit.Pairs.FirstOrDefault(p => p.Id == PairId);
        if (_pair == null) return;
        _layouts = dbInit.Layouts.Where(l => l.PairId == PairId).ToList();
        var layoutIds = _layouts.Select(l => l.Id).ToList();
        _slots = dbInit.Slots.Where(s => layoutIds.Contains(s.LayoutId))
                         .OrderBy(s => s.ZIndex)
                         .ToList();

        // Load placements for BOTH profiles so we can render both viewers' Pokémon simultaneously
        var slotIds = _slots.Select(sl => sl.Id).ToList();
        _placements = dbInit.SlotPlacements
            .Where(sp => slotIds.Contains(sp.SlotId))
            .ToDictionary(sp => (sp.SlotId, sp.Profile), sp => sp);

        // Normalize any legacy or external ImageUrl values so images render
        await NormalizeSlotImagesAsync(_slots);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && _authorized && _hub == null)
        {

            _hub = new HubConnectionBuilder()
                .WithUrl(Nav.ToAbsoluteUri("/hubs/layout"))
                .WithAutomaticReconnect(new Shared.SignalR.AdvancedRetryPolicy())
                .Build();
            // Typed envelope handler for forward-compatible messages (legacy dynamic handlers removed)
            _hub.On<PPSNR.Shared.SignalR.SignalRMessageEnvelope>("Message", envelope =>
            {
                try
                {
                    if (envelope == null) return;
                    if (string.Equals(envelope.Type, "SlotUpdated", StringComparison.OrdinalIgnoreCase) && envelope.Data.HasValue)
                    {
                        var dto = System.Text.Json.JsonSerializer.Deserialize<PPSNR.Shared.SignalR.SlotUpdatedDto>(envelope.Data.Value.GetRawText());
                        if (dto == null) return;

                        var id = dto.Id;
                        var profile = dto.Profile;
                        var x = dto.X;
                        var y = dto.Y;
                        var z = dto.ZIndex;
                        var vis = dto.Visible;
                        var img = dto.ImageUrl;
                        var width = dto.Width;
                        var height = dto.Height;

                        var slot = _slots.FirstOrDefault(s => s.Id == id);
                        if (slot != null)
                        {
                            if (img != null) slot.ImageUrl = img;
                            if (width.HasValue) slot.Width = width.Value;
                            if (height.HasValue) slot.Height = height.Value;
                            if (profile != null)
                            {
                                var prof = (SlotProfile)profile.Value;
                                if (_placements.TryGetValue((slot.Id, prof), out var placement))
                                {
                                    if (x.HasValue) placement.X = x.Value;
                                    if (y.HasValue) placement.Y = y.Value;
                                    if (z.HasValue) placement.ZIndex = z.Value;
                                    if (vis.HasValue) placement.Visible = vis.Value;
                                    if (width.HasValue) placement.Width = width.Value;
                                    if (height.HasValue) placement.Height = height.Value;
                                }
                            }
                            InvokeAsync(StateHasChanged);
                        }
                    }
                    else if (string.Equals(envelope.Type, "PlacementsReset", StringComparison.OrdinalIgnoreCase))
                    {
                        InvokeAsync(async () =>
                        {
                            await ReloadPlacementsAsync();
                            StateHasChanged();
                        });
                    }
                    else if (string.Equals(envelope.Type, "ToggleBorders", StringComparison.OrdinalIgnoreCase) && envelope.Data.HasValue)
                    {
                        try
                        {
                            var root = envelope.Data.Value;
                            if (root.TryGetProperty("show", out var s) && s.ValueKind == System.Text.Json.JsonValueKind.True || s.ValueKind == System.Text.Json.JsonValueKind.False)
                            {
                                var value = s.GetBoolean();
                                InvokeAsync(() => { _showBorders = value; StateHasChanged(); });
                            }
                        }
                        catch { /* ignore */ }
                    }
                }
                catch { /* ignore malformed event */ }
            });
            await _hub.StartAsync();
            await _hub.SendAsync("SubscribeToPair", PairId.ToString());
        }
    }

    public void Dispose()
    {
        _ = _hub?.DisposeAsync();
    }

    private async Task NormalizeSlotImagesAsync(IEnumerable<Slot> list)
    {
        var changed = false;
        foreach (var s in list)
        {
            if (!string.IsNullOrWhiteSpace(s.ImageUrl))
            {
                var url = s.ImageUrl!;
                if (!url.StartsWith("/"))
                {
                    try
                    {
                        var normalized = await ImagesCache.GetCachedImageUrlAsync(url);
                        if (!string.Equals(normalized, url, StringComparison.Ordinal))
                        {
                            s.ImageUrl = normalized;
                            changed = true;
                        }
                    }
                    catch
                    {
                        // ignore and keep original
                    }
                }
            }
        }
        if (changed)
        {
            await using var db = await DbFactory.CreateDbContextAsync();
            // Attach and update only changed slots
            foreach (var s in list.Where(x => !string.IsNullOrWhiteSpace(x.ImageUrl)))
            {
                db.Attach(s);
                db.Entry(s).Property(x => x.ImageUrl).IsModified = true;
            }
            await db.SaveChangesAsync();
        }
    }
}

@code {
    private async Task ReloadPlacementsAsync()
    {
        try
        {
            await using var db = await DbFactory.CreateDbContextAsync();
            var slotIds = _slots.Select(sl => sl.Id).ToList();
            _placements = db.SlotPlacements
                .Where(sp => slotIds.Contains(sp.SlotId))
                .ToDictionary(sp => (sp.SlotId, sp.Profile), sp => sp);
            await Task.CompletedTask;
        }
        catch
        {
            // ignore reload errors
        }
    }
    private static string GetSizeStyle(Slot s)
    {
        var w = s.Width;
        var h = s.Height;
        var style = string.Empty;
        if (w != null) style += $" width:{w}px;";
        if (h != null) style += $" height:{h}px;";
        return style;
    }

    private static int? GetWidth(Slot s) => s.Width;
    private static int? GetHeight(Slot s) => s.Height;

    // Removed legacy AdditionalProperties helpers; sizes are explicit now
}
