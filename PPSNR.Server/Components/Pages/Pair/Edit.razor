@page "/{pairId:guid}/edit/{token:guid}"
@page "/{pairId:guid}/partner-edit/{token:guid}"
@layout EmptyLayout
@rendermode InteractiveServer
@using PPSNR.Server.Components.Layout
@using PPSNR.Server.Data.Entities
@inject ApplicationDbContext Db
@inject IDbContextFactory<ApplicationDbContext> DbFactory
@inject NavigationManager Nav
@inject AuthenticationStateProvider Auth
@inject IJSRuntime JS
@inject Services.ImagesCacheService ImagesCache
@inject Services.LayoutService LayoutSvc

@* Styles moved to app.scss *@

@if (!authorized)
{
    <div class="hud">Forbidden. Invalid token.</div>
}
else if (layouts is null)
{
    <div class="hud">Loading...</div>
}
else
{
    <script>
        (function(){
            try{
                if (!window.PPSNR_Drag){
                    var s=document.createElement('script');
                    s.src='js/editor-drag.js';
                    s.defer=true;
                    document.head.appendChild(s);
                }
                if (!window.ppsnr){
                    var s2=document.createElement('script');
                    s2.src='js/antiforgery.js';
                    s2.defer=true;
                    document.head.appendChild(s2);
                }
            }catch(e){ console.warn('[edit] script inject failed', e); }
        })();
    </script>
    <div class="hud">
        <b>@pair?.Name</b> — Drag images to reposition@(editProfile == SlotProfile.Partner ? " (Partner)" : string.Empty). Changes auto-save.
        <button class="btn btn-sm btn-outline-light ms-2" @onclick="ResetToDefaultsAsync">Reset positions</button>
        <button class="btn btn-sm btn-warning ms-2" @onclick="ToggleBordersAsync">@(_bordersOn ? "Hide borders on OBS" : "Show borders on OBS")</button>
    </div>
    <div id="canvas" data-pair-id="@pairId">
        @foreach (var l in layouts)
        {
            @foreach (var s in slots.Where(x => x.LayoutId == l.Id))
            {
                <div class="@GetClass(s)" style="@GetStyle(s)" data-slot-id="@s.Id.ToString()" data-layout-id="@l.Id.ToString()" data-z-index="@GetZIndex(s).ToString()" data-visible="@GetVisibleAttr(s)" data-image-url="@GetImageSrc(s)" data-index="@s.Index.ToString()">
                    <img src="@GetImageSrc(s)" draggable="false" alt="@GetAltText(s)" />
                    <span class="resizer nw" data-dir="nw"></span>
                    <span class="resizer n" data-dir="n"></span>
                    <span class="resizer ne" data-dir="ne"></span>
                    <span class="resizer e" data-dir="e"></span>
                    <span class="resizer se" data-dir="se"></span>
                    <span class="resizer s" data-dir="s"></span>
                    <span class="resizer sw" data-dir="sw"></span>
                    <span class="resizer w" data-dir="w"></span>
                </div>
            }
        }
    </div>
}

@code {
    [Parameter] public Guid pairId { get; set; }
    [Parameter] public Guid token { get; set; }

    private bool authorized;
    private StreamerPair? pair;
    private List<Layout>? layouts;
    private List<Slot> slots = new();
    private Dictionary<Guid, SlotPlacement> placements = new();
    private HubConnection? hub;
    private const string TransparentPng = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAoMBgVqvJi8AAAAASUVORK5CYII=";
    private SlotProfile editProfile;
    private bool _jsReady; // set after first interactive render completes
    private bool _pendingClearInlineGeometry; // request to run JS clear when next render is ready
    private bool _disposed; // component is being disposed (circuit disconnect/navigation)
    private bool _bordersOn; // current requested borders state sent to viewers

    protected override async Task OnInitializedAsync()
    {
        // Validate token for both owner and partner edit flows
        var link = Db.PairLinks.FirstOrDefault(l => l.PairId == pairId);
        authorized = false;
        if (link != null && (link.ExpiresAt == null || link.ExpiresAt > DateTime.UtcNow))
        {
            // Owner edit flow
            if (link.EditToken == token)
            {
                pair = Db.Pairs.FirstOrDefault(p => p.Id == pairId);
                var state = await Auth.GetAuthenticationStateAsync();
                var userId = state.User?.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value;
                if (pair != null && !string.IsNullOrEmpty(userId) && string.Equals(pair.OwnerUserId, userId, StringComparison.Ordinal))
                {
                    authorized = true;
                    editProfile = SlotProfile.Owner;
                }
            }
            // Partner edit flow
            else if (link.PartnerEditToken == token)
            {
                pair = Db.Pairs.FirstOrDefault(p => p.Id == pairId);
                if (pair != null)
                {
                    authorized = true;
                    editProfile = SlotProfile.Partner;
                }
            }
        }
        if (!authorized) return;

        layouts = Db.Layouts.Where(l => l.PairId == pairId).ToList();
        var layoutIds = layouts.Select(l => l.Id).ToList();
        // Show all slots for both profiles so editors can see the counterpart as well
        // Positions are rendered using the editor's profile placement for every slot (owner or partner)
        slots = Db.Slots.Where(s => layoutIds.Contains(s.LayoutId))
                        .OrderBy(s => s.ZIndex)
                        .ToList();

        // Load placements for the current editor profile across all these slots
        var slotIds = slots.Select(s => s.Id).ToList();
        placements = Db.SlotPlacements
            .Where(p => slotIds.Contains(p.SlotId) && p.Profile == editProfile)
            .ToDictionary(p => p.SlotId, p => p);

        // Normalize any legacy or external ImageUrl values to cached /resources paths so images render
        await NormalizeSlotImagesAsync(slots);

        // SignalR to see live updates from other editors
        hub = new HubConnectionBuilder()
            .WithUrl(Nav.ToAbsoluteUri("/hubs/layout"))
            .WithAutomaticReconnect(new Shared.SignalR.AdvancedRetryPolicy())
            .Build();
        // Typed envelope handler for forward-compatible messages
        hub.On<PPSNR.Shared.SignalR.SignalRMessageEnvelope>("Message", envelope =>
        {
            try
            {
                if (envelope == null) return;
                if (string.Equals(envelope.Type, "SlotUpdated", StringComparison.OrdinalIgnoreCase) && envelope.Data.HasValue)
                {
                    var dto = System.Text.Json.JsonSerializer.Deserialize<PPSNR.Shared.SignalR.SlotUpdatedDto>(envelope.Data.Value.GetRawText());
                    if (dto == null) return;

                    var id = dto.Id;
                    var profile = dto.Profile;
                    var x = dto.X;
                    var y = dto.Y;
                    var z = dto.ZIndex;
                    var vis = dto.Visible;
                    var img = dto.ImageUrl;
                    var width = dto.Width;
                    var height = dto.Height;

                    var slot = slots.FirstOrDefault(s => s.Id == id);
                    if (slot != null)
                    {
                        if (profile != null && (int)editProfile == profile)
                        {
                            if (placements.TryGetValue(slot.Id, out var pl))
                            {
                                if (x.HasValue) pl.X = x.Value;
                                if (y.HasValue) pl.Y = y.Value;
                                if (z.HasValue) pl.ZIndex = z.Value;
                                if (vis.HasValue) pl.Visible = vis.Value;
                                if (width.HasValue) pl.Width = width.Value;
                                if (height.HasValue) pl.Height = height.Value;
                            }
                        }
                        if (dto.ImageUrl != null)
                        {
                            slot.ImageUrl = dto.ImageUrl;
                        }
                        if (width.HasValue) slot.Width = width.Value;
                        if (height.HasValue) slot.Height = height.Value;
                        InvokeAsync(StateHasChanged);
                    }
                }
            }
            catch { /* ignore malformed messages */ }
        });
        await hub.StartAsync();
        await hub.SendAsync("SubscribeToPair", pairId.ToString());
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && authorized)
        {
            var apiBase = editProfile == SlotProfile.Partner ? $"/api/partner/{token}" : "/api";
            try
            {
                await JS.InvokeVoidAsync("PPSNR_Drag.init", apiBase, pairId.ToString());
                _jsReady = true;
            }
            catch (JSDisconnectedException)
            {
                // Circuit not ready; will try again on next render
                _jsReady = false;
            }
            catch (ObjectDisposedException)
            {
                _jsReady = false;
            }
        }

        // After any render, if we have a pending JS clear request and JS is ready, execute it safely
        if (_pendingClearInlineGeometry && _jsReady && !_disposed)
        {
            try
            {
                await JS.InvokeVoidAsync("PPSNR_Drag.clearInlineGeometry");
            }
            catch (JSDisconnectedException)
            {
                // Ignore; circuit disconnected
            }
            catch (ObjectDisposedException)
            {
                // Ignore
            }
            finally
            {
                _pendingClearInlineGeometry = false;
            }
        }
    }

    private async Task ToggleBordersAsync()
    {
        _bordersOn = !_bordersOn;
        // Broadcast to viewers via SignalR so the existing OBS browser source updates live
        await LayoutSvc.BroadcastToggleBordersAsync(pairId, _bordersOn);
    }

    private static string GetAltText(Slot s)
    {
        return s.SlotType is SlotType.Pokemon ? "Pokemon" : "Badge";
    }
    private string GetStyle(Slot s)
    {
        float x = s.X;
        float y = s.Y;
        int z = s.ZIndex;
        int? widthFromPlacement = null;
        int? heightFromPlacement = null;
        if (placements.TryGetValue(s.Id, out var p))
        {
            x = p.X;
            y = p.Y;
            z = p.ZIndex;
            widthFromPlacement = p.Width;
            heightFromPlacement = p.Height;
        }
        var style = $"left:{x}px; top:{y}px; z-index:{z};";
        // Prefer size from placement when available; fall back to slot Width/Height
        int? w = widthFromPlacement;
        int? h = heightFromPlacement;
        if (w == null && h == null) { w = s.Width; h = s.Height; }
        if (!string.IsNullOrEmpty(s.ImageUrl))
        {
            // If no explicit size set, provide a sensible default to avoid huge official artwork
            if (w == null && h == null)
            {
                w = s.SlotType == SlotType.Pokemon ? 256 : 96;
            }
        }
        else
        {
            // For placeholders ensure a minimum box to drag
            w ??= s.SlotType == SlotType.Pokemon ? 128 : 48;
            h ??= w;
        }

        if (w != null) style += $" width:{w}px;";
        if (h != null) style += $" height:{h}px;";
        return style;
    }
    private string GetClass(Slot s)
    {
        var visible = GetVisible(s);
        return visible ? "drag" : "drag inactive";
    }
    private bool GetVisible(Slot s)
    {
        if (placements.TryGetValue(s.Id, out var p)) return p.Visible;
        return s.Visible;
    }
    private string GetVisibleAttr(Slot s) => GetVisible(s) ? "true" : "false";
    private int GetZIndex(Slot s)
    {
        if (placements.TryGetValue(s.Id, out var p)) return p.ZIndex;
        return s.ZIndex;
    }
    private string GetImageSrc(Slot s) => string.IsNullOrWhiteSpace(s.ImageUrl) ? TransparentPng : s.ImageUrl!;
    // sizes are derived from placement or Slot.Width/Height; JS reads sizes from inline style

    private async Task NormalizeSlotImagesAsync(IEnumerable<Slot> list)
    {
        var changed = false;
        foreach (var s in list)
        {
            if (!string.IsNullOrWhiteSpace(s.ImageUrl))
            {
                var url = s.ImageUrl!;
                if (!url.StartsWith("/"))
                {
                    try
                    {
                        var normalized = await ImagesCache.GetCachedImageUrlAsync(url);
                        if (!string.Equals(normalized, url, StringComparison.Ordinal))
                        {
                            s.ImageUrl = normalized;
                            changed = true;
                        }
                    }
                    catch
                    {
                        // ignore normalization failures; keep original so user can fix in selection UI
                    }
                }
            }
        }
        if (changed)
        {
            await Db.SaveChangesAsync();
        }
    }
}

@code {
    private async Task ResetToDefaultsAsync()
    {
        if (!authorized || pair == null) return;
        try
        {
            // Reset placements for the current editing profile
            await LayoutSvc.ResetPlacementsToDefaultsAsync(pairId, editProfile);

            // Reload placements from DB for current profile using a fresh context (avoid stale tracked entities)
            await ReloadPlacementsForCurrentProfileAsync();
            // Defer JS to render phase to avoid disconnected/prerender issues
            _pendingClearInlineGeometry = true;
            StateHasChanged();
        }
        catch
        {
            // no-op on failure; UI remains unchanged
        }
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            _disposed = true;
            if (hub is not null)
            {
                await hub.DisposeAsync();
            }
        }
        catch { /* ignore */ }
    }
    private async Task ReloadPlacementsForCurrentProfileAsync()
    {
        await using var fresh = await DbFactory.CreateDbContextAsync();
        var slotIds = slots.Select(s => s.Id).ToList();
        placements = fresh.SlotPlacements
            .Where(p => slotIds.Contains(p.SlotId) && p.Profile == editProfile)
            .AsNoTracking()
            .ToDictionary(p => p.SlotId, p => p);
    }
    // Removed AdditionalProperties parsing helpers; width/height are explicit now
}
