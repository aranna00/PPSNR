<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/PPSNR.Server-AI/Program.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/PPSNR.Server-AI/Program.cs" />
              <option name="originalContent" value="using Microsoft.AspNetCore.Components.Authorization;&#10;using Microsoft.AspNetCore.Identity;&#10;using Microsoft.EntityFrameworkCore;&#10;using PPSNR.Server.Components;&#10;using PPSNR.Server.Components.Account;&#10;using PPSNR.Server.Data;&#10;&#10;var builder = WebApplication.CreateBuilder(args);&#10;&#10;// Add services to the container.&#10;builder.Services.AddRazorComponents()&#10;    .AddInteractiveServerComponents();&#10;&#10;builder.Services.AddCascadingAuthenticationState();&#10;builder.Services.AddScoped&lt;IdentityRedirectManager&gt;();&#10;builder.Services.AddScoped&lt;AuthenticationStateProvider, IdentityRevalidatingAuthenticationStateProvider&gt;();&#10;&#10;builder.Services.AddAuthentication(options =&gt;&#10;    {&#10;        options.DefaultScheme = IdentityConstants.ApplicationScheme;&#10;        options.DefaultSignInScheme = IdentityConstants.ExternalScheme;&#10;    })&#10;    .AddIdentityCookies();&#10;&#10;var connectionString = builder.Configuration.GetConnectionString(&quot;DefaultConnection&quot;) ?? throw new InvalidOperationException(&quot;Connection string 'DefaultConnection' not found.&quot;);&#10;builder.Services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt;&#10;    options.UseSqlite(connectionString));&#10;builder.Services.AddDatabaseDeveloperPageExceptionFilter();&#10;&#10;builder.Services.AddIdentityCore&lt;ApplicationUser&gt;(options =&gt;&#10;    {&#10;        options.SignIn.RequireConfirmedAccount = true;&#10;        options.Stores.SchemaVersion = IdentitySchemaVersions.Version3;&#10;    })&#10;    .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;()&#10;    .AddSignInManager()&#10;    .AddDefaultTokenProviders();&#10;&#10;builder.Services.AddSingleton&lt;IEmailSender&lt;ApplicationUser&gt;, IdentityNoOpEmailSender&gt;();&#10;&#10;var app = builder.Build();&#10;&#10;// Configure the HTTP request pipeline.&#10;if (app.Environment.IsDevelopment())&#10;{&#10;    app.UseMigrationsEndPoint();&#10;}&#10;else&#10;{&#10;    app.UseExceptionHandler(&quot;/Error&quot;, createScopeForErrors: true);&#10;    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.&#10;    app.UseHsts();&#10;}&#10;app.UseStatusCodePagesWithReExecute(&quot;/not-found&quot;, createScopeForStatusCodePages: true);&#10;app.UseHttpsRedirection();&#10;&#10;// Do not register global antiforgery middleware here; validate antiforgery&#10;// explicitly in API POST endpoints. Global registration can force GET pages&#10;// to be validated and cause missing-cookie errors for view pages.&#10;&#10;app.MapStaticAssets();&#10;app.MapRazorComponents&lt;App&gt;()&#10;    .AddInteractiveServerRenderMode();&#10;&#10;// Add additional endpoints required by the Identity /Account Razor components.&#10;app.MapAdditionalIdentityEndpoints();&#10;&#10;app.Run();&#10;" />
              <option name="updatedContent" value="using Microsoft.AspNetCore.Components.Authorization;&#13;&#10;using Microsoft.AspNetCore.Identity;&#13;&#10;using Microsoft.EntityFrameworkCore;&#13;&#10;using PPSNR.Server.Components;&#13;&#10;using PPSNR.Server.Components.Account;&#13;&#10;using PPSNR.Server.Data;&#13;&#10;&#13;&#10;var builder = WebApplication.CreateBuilder(args);&#13;&#10;&#13;&#10;// Add services to the container.&#13;&#10;builder.Services.AddRazorComponents()&#13;&#10;    .AddInteractiveServerComponents();&#13;&#10;&#13;&#10;builder.Services.AddCascadingAuthenticationState();&#13;&#10;builder.Services.AddScoped&lt;IdentityRedirectManager&gt;();&#13;&#10;builder.Services.AddScoped&lt;AuthenticationStateProvider, IdentityRevalidatingAuthenticationStateProvider&gt;();&#13;&#10;&#13;&#10;builder.Services.AddAuthentication(options =&gt;&#13;&#10;    {&#13;&#10;        options.DefaultScheme = IdentityConstants.ApplicationScheme;&#13;&#10;        options.DefaultSignInScheme = IdentityConstants.ExternalScheme;&#13;&#10;    })&#13;&#10;    .AddIdentityCookies();&#13;&#10;&#13;&#10;var connectionString = builder.Configuration.GetConnectionString(&quot;DefaultConnection&quot;) ?? throw new InvalidOperationException(&quot;Connection string 'DefaultConnection' not found.&quot;);&#13;&#10;builder.Services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt;&#13;&#10;    options.UseSqlite(connectionString));&#13;&#10;builder.Services.AddDatabaseDeveloperPageExceptionFilter();&#13;&#10;&#13;&#10;builder.Services.AddIdentityCore&lt;ApplicationUser&gt;(options =&gt;&#13;&#10;    {&#13;&#10;        options.SignIn.RequireConfirmedAccount = true;&#13;&#10;        options.Stores.SchemaVersion = IdentitySchemaVersions.Version3;&#13;&#10;    })&#13;&#10;    .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;()&#13;&#10;    .AddSignInManager()&#13;&#10;    .AddDefaultTokenProviders();&#13;&#10;&#13;&#10;builder.Services.AddSingleton&lt;IEmailSender&lt;ApplicationUser&gt;, IdentityNoOpEmailSender&gt;();&#13;&#10;&#13;&#10;var app = builder.Build();&#13;&#10;&#13;&#10;// Configure the HTTP request pipeline.&#13;&#10;if (app.Environment.IsDevelopment())&#13;&#10;{&#13;&#10;    app.UseMigrationsEndPoint();&#13;&#10;}&#13;&#10;else&#13;&#10;{&#13;&#10;    app.UseExceptionHandler(&quot;/Error&quot;, createScopeForErrors: true);&#13;&#10;    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.&#13;&#10;    app.UseHsts();&#13;&#10;}&#13;&#10;app.UseStatusCodePagesWithReExecute(&quot;/not-found&quot;, createScopeForStatusCodePages: true);&#13;&#10;app.UseHttpsRedirection();&#13;&#10;&#13;&#10;// Do not register global antiforgery middleware here; validate antiforgery&#13;&#10;// explicitly in API POST endpoints. Global registration can force GET pages&#13;&#10;// to be validated and cause missing-cookie errors for view pages.&#13;&#10;&#13;&#10;app.MapStaticAssets();&#13;&#10;app.MapRazorComponents&lt;App&gt;()&#13;&#10;    .AddInteractiveServerRenderMode();&#13;&#10;&#13;&#10;// Add additional endpoints required by the Identity /Account Razor components.&#13;&#10;app.MapAdditionalIdentityEndpoints();&#13;&#10;&#13;&#10;app.Run();" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/PPSNR.Server/Components/Pages/Pair/Edit.razor">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/PPSNR.Server/Components/Pages/Pair/Edit.razor" />
              <option name="originalContent" value="@page &quot;/{pairId:guid}/edit/{token:guid}&quot;&#10;@page &quot;/{pairId:guid}/partner-edit/{token:guid}&quot;&#10;@layout EmptyLayout&#10;@rendermode InteractiveServer&#10;@using PPSNR.Server.Components.Layout&#10;@using PPSNR.Server.Data.Entities&#10;@using Microsoft.EntityFrameworkCore&#10;@inject ApplicationDbContext Db&#10;@inject IDbContextFactory&lt;ApplicationDbContext&gt; DbFactory&#10;@inject NavigationManager Nav&#10;@inject AuthenticationStateProvider Auth&#10;@inject IJSRuntime JS&#10;@inject Services.ImagesCacheService ImagesCache&#10;@inject Services.LayoutService LayoutSvc&#10;&#10;@* Styles moved to app.scss *@&#10;&#10;@if (!authorized)&#10;{&#10;    &lt;div class=&quot;hud&quot;&gt;Forbidden. Invalid token.&lt;/div&gt;&#10;}&#10;else if (layouts is null)&#10;{&#10;    &lt;div class=&quot;hud&quot;&gt;Loading...&lt;/div&gt;&#10;}&#10;else&#10;{&#10;    &lt;script&gt;&#10;        (function(){&#10;            try{&#10;                if (!window.PPSNR_Drag){&#10;                    var s=document.createElement('script');&#10;                    s.src='js/editor-drag.js';&#10;                    s.defer=true;&#10;                    document.head.appendChild(s);&#10;                }&#10;                if (!window.ppsnr){&#10;                    var s2=document.createElement('script');&#10;                    s2.src='js/antiforgery.js';&#10;                    s2.defer=true;&#10;                    document.head.appendChild(s2);&#10;                }&#10;            }catch(e){ console.warn('[edit] script inject failed', e); }&#10;        })();&#10;    &lt;/script&gt;&#10;    &lt;div class=&quot;hud&quot;&gt;&#10;        &lt;b&gt;@pair?.Name&lt;/b&gt; — Drag images to reposition@(editProfile == SlotProfile.Partner ? &quot; (Partner)&quot; : string.Empty). Changes auto-save.&#10;        &lt;button class=&quot;btn btn-sm btn-outline-light ms-2&quot; @onclick=&quot;ResetToDefaultsAsync&quot;&gt;Reset positions&lt;/button&gt;&#10;    &lt;/div&gt;&#10;    &lt;div id=&quot;canvas&quot; data-pair-id=&quot;@pairId&quot;&gt;&#10;        @foreach (var l in layouts)&#10;        {&#10;            @foreach (var s in slots.Where(x =&gt; x.LayoutId == l.Id))&#10;            {&#10;                &lt;div class=&quot;@GetClass(s)&quot; style=&quot;@GetStyle(s)&quot; data-slot-id=&quot;@s.Id.ToString()&quot; data-layout-id=&quot;@l.Id.ToString()&quot; data-z-index=&quot;@GetZIndex(s).ToString()&quot; data-visible=&quot;@GetVisibleAttr(s)&quot; data-image-url=&quot;@GetImageSrc(s)&quot; data-index=&quot;@s.Index.ToString()&quot;&gt;&#10;                    &lt;img src=&quot;@GetImageSrc(s)&quot; draggable=&quot;false&quot; alt=&quot;slot&quot; /&gt;&#10;                    &lt;span class=&quot;resizer nw&quot; data-dir=&quot;nw&quot;&gt;&lt;/span&gt;&#10;                    &lt;span class=&quot;resizer n&quot; data-dir=&quot;n&quot;&gt;&lt;/span&gt;&#10;                    &lt;span class=&quot;resizer ne&quot; data-dir=&quot;ne&quot;&gt;&lt;/span&gt;&#10;                    &lt;span class=&quot;resizer e&quot; data-dir=&quot;e&quot;&gt;&lt;/span&gt;&#10;                    &lt;span class=&quot;resizer se&quot; data-dir=&quot;se&quot;&gt;&lt;/span&gt;&#10;                    &lt;span class=&quot;resizer s&quot; data-dir=&quot;s&quot;&gt;&lt;/span&gt;&#10;                    &lt;span class=&quot;resizer sw&quot; data-dir=&quot;sw&quot;&gt;&lt;/span&gt;&#10;                    &lt;span class=&quot;resizer w&quot; data-dir=&quot;w&quot;&gt;&lt;/span&gt;&#10;                &lt;/div&gt;&#10;            }&#10;        }&#10;    &lt;/div&gt;&#10;}&#10;&#10;@code {&#10;    [Parameter] public Guid pairId { get; set; }&#10;    [Parameter] public Guid token { get; set; }&#10;&#10;    private bool authorized;&#10;    private StreamerPair? pair;&#10;    private List&lt;Layout&gt;? layouts;&#10;    private List&lt;Slot&gt; slots = new();&#10;    private Dictionary&lt;Guid, SlotPlacement&gt; placements = new();&#10;    private HubConnection? hub;&#10;    private const string TransparentPng = &quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAoMBgVqvJi8AAAAASUVORK5CYII=&quot;;&#10;    private SlotProfile editProfile;&#10;    private bool _jsReady; // set after first interactive render completes&#10;    private bool _pendingClearInlineGeometry; // request to run JS clear when next render is ready&#10;    private bool _disposed; // component is being disposed (circuit disconnect/navigation)&#10;&#10;    protected override async Task OnInitializedAsync()&#10;    {&#10;        // Validate token for both owner and partner edit flows&#10;        var link = Db.PairLinks.FirstOrDefault(l =&gt; l.PairId == pairId);&#10;        authorized = false;&#10;        if (link != null &amp;&amp; (link.ExpiresAt == null || link.ExpiresAt &gt; DateTime.UtcNow))&#10;        {&#10;            // Owner edit flow&#10;            if (link.EditToken == token)&#10;            {&#10;                pair = Db.Pairs.FirstOrDefault(p =&gt; p.Id == pairId);&#10;                var state = await Auth.GetAuthenticationStateAsync();&#10;                var userId = state.User?.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value;&#10;                if (pair != null &amp;&amp; !string.IsNullOrEmpty(userId) &amp;&amp; string.Equals(pair.OwnerUserId, userId, StringComparison.Ordinal))&#10;                {&#10;                    authorized = true;&#10;                    editProfile = SlotProfile.Owner;&#10;                }&#10;            }&#10;            // Partner edit flow&#10;            else if (link.PartnerEditToken == token)&#10;            {&#10;                pair = Db.Pairs.FirstOrDefault(p =&gt; p.Id == pairId);&#10;                if (pair != null)&#10;                {&#10;                    authorized = true;&#10;                    editProfile = SlotProfile.Partner;&#10;                }&#10;            }&#10;        }&#10;        if (!authorized) return;&#10;&#10;        layouts = Db.Layouts.Where(l =&gt; l.PairId == pairId).ToList();&#10;        var layoutIds = layouts.Select(l =&gt; l.Id).ToList();&#10;        // Show all slots for both profiles so editors can see the counterpart as well&#10;        // Positions are rendered using the editor's profile placement for every slot (owner or partner)&#10;        slots = Db.Slots.Where(s =&gt; layoutIds.Contains(s.LayoutId))&#10;                        .OrderBy(s =&gt; s.ZIndex)&#10;                        .ToList();&#10;&#10;        // Load placements for the current editor profile across all these slots&#10;        var slotIds = slots.Select(s =&gt; s.Id).ToList();&#10;        placements = Db.SlotPlacements&#10;            .Where(p =&gt; slotIds.Contains(p.SlotId) &amp;&amp; p.Profile == editProfile)&#10;            .ToDictionary(p =&gt; p.SlotId, p =&gt; p);&#10;&#10;        // Normalize any legacy or external ImageUrl values to cached /resources paths so images render&#10;        await NormalizeSlotImagesAsync(slots);&#10;&#10;        // SignalR to see live updates from other editors&#10;        hub = new HubConnectionBuilder().WithUrl(Nav.ToAbsoluteUri(&quot;/hubs/layout&quot;)).WithAutomaticReconnect().Build();&#10;        // Typed envelope handler for forward-compatible messages&#10;        hub.On&lt;PPSNR.Shared.SignalR.SignalRMessageEnvelope&gt;(&quot;Message&quot;, envelope =&gt;&#10;        {&#10;            try&#10;            {&#10;                if (envelope == null) return;&#10;                if (string.Equals(envelope.Type, &quot;SlotUpdated&quot;, StringComparison.OrdinalIgnoreCase) &amp;&amp; envelope.Data.HasValue)&#10;                {&#10;                    var dto = System.Text.Json.JsonSerializer.Deserialize&lt;PPSNR.Shared.SignalR.SlotUpdatedDto&gt;(envelope.Data.Value.GetRawText());&#10;                    if (dto == null) return;&#10;&#10;                    var id = dto.Id;&#10;                    var profile = dto.Profile;&#10;                    var x = dto.X;&#10;                    var y = dto.Y;&#10;                    var z = dto.ZIndex;&#10;                    var vis = dto.Visible;&#10;                    var img = dto.ImageUrl;&#10;                    var add = dto.AdditionalProperties;&#10;                    var width = dto.Width;&#10;                    var height = dto.Height;&#10;&#10;                    var slot = slots.FirstOrDefault(s =&gt; s.Id == id);&#10;                    if (slot != null)&#10;                    {&#10;                        if (profile != null &amp;&amp; (int)editProfile == profile)&#10;                        {&#10;                            if (placements.TryGetValue(slot.Id, out var pl))&#10;                            {&#10;                                if (x.HasValue) pl.X = x.Value;&#10;                                if (y.HasValue) pl.Y = y.Value;&#10;                                if (z.HasValue) pl.ZIndex = z.Value;&#10;                                if (vis.HasValue) pl.Visible = vis.Value;&#10;                                if (width.HasValue) pl.Width = width.Value;&#10;                                if (height.HasValue) pl.Height = height.Value;&#10;                            }&#10;                        }&#10;                        if (dto.ImageUrl != null)&#10;                        {&#10;                            slot.ImageUrl = dto.ImageUrl;&#10;                        }&#10;                        if (dto.AdditionalProperties != null)&#10;                        {&#10;                            slot.AdditionalProperties = dto.AdditionalProperties;&#10;                        }&#10;                        InvokeAsync(StateHasChanged);&#10;                    }&#10;                }&#10;            }&#10;            catch { /* ignore malformed messages */ }&#10;        });&#10;        await hub.StartAsync();&#10;        await hub.SendAsync(&quot;SubscribeToPair&quot;, pairId.ToString());&#10;    }&#10;&#10;    protected override async Task OnAfterRenderAsync(bool firstRender)&#10;    {&#10;        if (firstRender &amp;&amp; authorized)&#10;        {&#10;            var apiBase = editProfile == SlotProfile.Partner ? $&quot;/api/partner/{token}&quot; : &quot;/api&quot;;&#10;            try&#10;            {&#10;                await JS.InvokeVoidAsync(&quot;PPSNR_Drag.init&quot;, apiBase, pairId.ToString());&#10;                _jsReady = true;&#10;            }&#10;            catch (Microsoft.JSInterop.JSDisconnectedException)&#10;            {&#10;                // Circuit not ready; will try again on next render&#10;                _jsReady = false;&#10;            }&#10;            catch (ObjectDisposedException)&#10;            {&#10;                _jsReady = false;&#10;            }&#10;        }&#10;&#10;        // After any render, if we have a pending JS clear request and JS is ready, execute it safely&#10;        if (_pendingClearInlineGeometry &amp;&amp; _jsReady &amp;&amp; !_disposed)&#10;        {&#10;            try&#10;            {&#10;                await JS.InvokeVoidAsync(&quot;PPSNR_Drag.clearInlineGeometry&quot;);&#10;            }&#10;            catch (Microsoft.JSInterop.JSDisconnectedException)&#10;            {&#10;                // Ignore; circuit disconnected&#10;            }&#10;            catch (ObjectDisposedException)&#10;            {&#10;                // Ignore&#10;            }&#10;            finally&#10;            {&#10;                _pendingClearInlineGeometry = false;&#10;            }&#10;        }&#10;    }&#10;    private string GetStyle(Slot s)&#10;    {&#10;        float x = s.X;&#10;        float y = s.Y;&#10;        int z = s.ZIndex;&#10;        int? widthFromPlacement = null;&#10;        int? heightFromPlacement = null;&#10;        if (placements.TryGetValue(s.Id, out var p))&#10;        {&#10;            x = p.X;&#10;            y = p.Y;&#10;            z = p.ZIndex;&#10;            widthFromPlacement = p.Width;&#10;            heightFromPlacement = p.Height;&#10;        }&#10;        var style = $&quot;left:{x}px; top:{y}px; z-index:{z};&quot;;&#10;        // Prefer size from placement when available; fall back to slot additional properties&#10;        int? w = widthFromPlacement;&#10;        int? h = heightFromPlacement;&#10;        if (w == null &amp;&amp; h == null)&#10;        {&#10;            var sz = GetSizeFromAdditional(s);&#10;            w = sz.w; h = sz.h;&#10;        }&#10;        if (!string.IsNullOrEmpty(s.ImageUrl))&#10;        {&#10;            // If no explicit size set, provide a sensible default to avoid huge official artwork&#10;            if (w == null &amp;&amp; h == null)&#10;            {&#10;                w = s.SlotType == SlotType.Pokemon ? 256 : 96;&#10;            }&#10;        }&#10;        else&#10;        {&#10;            // For placeholders ensure a minimum box to drag&#10;            w ??= s.SlotType == SlotType.Pokemon ? 128 : 48;&#10;            h ??= w;&#10;        }&#10;&#10;        if (w != null) style += $&quot; width:{w}px;&quot;;&#10;        if (h != null) style += $&quot; height:{h}px;&quot;;&#10;        return style;&#10;    }&#10;    private string GetClass(Slot s)&#10;    {&#10;        var visible = GetVisible(s);&#10;        return visible ? &quot;drag&quot; : &quot;drag inactive&quot;;&#10;    }&#10;    private bool GetVisible(Slot s)&#10;    {&#10;        if (placements.TryGetValue(s.Id, out var p)) return p.Visible;&#10;        return s.Visible;&#10;    }&#10;    private string GetVisibleAttr(Slot s) =&gt; GetVisible(s) ? &quot;true&quot; : &quot;false&quot;;&#10;    private int GetZIndex(Slot s)&#10;    {&#10;        if (placements.TryGetValue(s.Id, out var p)) return p.ZIndex;&#10;        return s.ZIndex;&#10;    }&#10;    private string GetImageSrc(Slot s) =&gt; string.IsNullOrWhiteSpace(s.ImageUrl) ? TransparentPng : s.ImageUrl!;&#10;    // additional properties are not emitted as a data attribute to avoid large attribute values; JS reads sizes from inline style&#10;&#10;    private async Task NormalizeSlotImagesAsync(IEnumerable&lt;Slot&gt; list)&#10;    {&#10;        var changed = false;&#10;        foreach (var s in list)&#10;        {&#10;            if (!string.IsNullOrWhiteSpace(s.ImageUrl))&#10;            {&#10;                var url = s.ImageUrl!;&#10;                if (!url.StartsWith(&quot;/&quot;))&#10;                {&#10;                    try&#10;                    {&#10;                        var normalized = await ImagesCache.GetCachedImageUrlAsync(url);&#10;                        if (!string.Equals(normalized, url, StringComparison.Ordinal))&#10;                        {&#10;                            s.ImageUrl = normalized;&#10;                            changed = true;&#10;                        }&#10;                    }&#10;                    catch&#10;                    {&#10;                        // ignore normalization failures; keep original so user can fix in selection UI&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        if (changed)&#10;        {&#10;            await Db.SaveChangesAsync();&#10;        }&#10;    }&#10;}&#10;&#10;@code {&#10;    private async Task ResetToDefaultsAsync()&#10;    {&#10;        if (!authorized || pair == null) return;&#10;        try&#10;        {&#10;            // Reset placements for the current editing profile&#10;            await LayoutSvc.ResetPlacementsToDefaultsAsync(pairId, editProfile);&#10;&#10;            // Reload placements from DB for current profile using a fresh context (avoid stale tracked entities)&#10;            await ReloadPlacementsForCurrentProfileAsync();&#10;            // Defer JS to render phase to avoid disconnected/prerender issues&#10;            _pendingClearInlineGeometry = true;&#10;            StateHasChanged();&#10;        }&#10;        catch&#10;        {&#10;            // no-op on failure; UI remains unchanged&#10;        }&#10;    }&#10;&#10;    public async ValueTask DisposeAsync()&#10;    {&#10;        try&#10;        {&#10;            _disposed = true;&#10;            if (hub is not null)&#10;            {&#10;                await hub.DisposeAsync();&#10;            }&#10;        }&#10;        catch { /* ignore */ }&#10;    }&#10;    private async Task ReloadPlacementsForCurrentProfileAsync()&#10;    {&#10;        await using var fresh = await DbFactory.CreateDbContextAsync();&#10;        var slotIds = slots.Select(s =&gt; s.Id).ToList();&#10;        placements = fresh.SlotPlacements&#10;            .Where(p =&gt; slotIds.Contains(p.SlotId) &amp;&amp; p.Profile == editProfile)&#10;            .AsNoTracking()&#10;            .ToDictionary(p =&gt; p.SlotId, p =&gt; p);&#10;    }&#10;    private (int? w, int? h) GetSizeFromAdditional(Slot s)&#10;    {&#10;        try&#10;        {&#10;            if (string.IsNullOrWhiteSpace(s.AdditionalProperties)) return (null, null);&#10;            using var doc = System.Text.Json.JsonDocument.Parse(s.AdditionalProperties);&#10;            var root = doc.RootElement;&#10;            int? w = null, h = null;&#10;            if (TryGetPropertyCI(root, &quot;w&quot;, out var wProp) &amp;&amp; wProp.ValueKind == System.Text.Json.JsonValueKind.Number)&#10;            {&#10;                var v = (int)wProp.GetDouble();&#10;                if (v &gt; 0) w = v;&#10;            }&#10;            if (TryGetPropertyCI(root, &quot;h&quot;, out var hProp) &amp;&amp; hProp.ValueKind == System.Text.Json.JsonValueKind.Number)&#10;            {&#10;                var v = (int)hProp.GetDouble();&#10;                if (v &gt; 0) h = v;&#10;            }&#10;            return (w, h);&#10;        }&#10;        catch&#10;        {&#10;            return (null, null);&#10;        }&#10;    }&#10;    private static bool TryGetPropertyCI(System.Text.Json.JsonElement el, string name, out System.Text.Json.JsonElement prop)&#10;    {&#10;        if (el.TryGetProperty(name, out prop)) return true;&#10;        var camel = LowerFirst(name);&#10;        return el.TryGetProperty(camel, out prop);&#10;    }&#10;    private static bool TryGetValueCI(IDictionary&lt;string, object&gt; dict, string name, out object? value)&#10;    {&#10;        if (dict.TryGetValue(name, out value)) return true;&#10;        var camel = LowerFirst(name);&#10;        return dict.TryGetValue(camel, out value);&#10;    }&#10;    private static string LowerFirst(string s)&#10;        =&gt; string.IsNullOrEmpty(s) ? s : char.ToLowerInvariant(s[0]) + s.Substring(1);&#10;}&#10;" />
              <option name="updatedContent" value="@page &quot;/{pairId:guid}/edit/{token:guid}&quot;&#10;@page &quot;/{pairId:guid}/partner-edit/{token:guid}&quot;&#10;@layout EmptyLayout&#10;@rendermode InteractiveServer&#10;@using PPSNR.Server.Components.Layout&#10;@using PPSNR.Server.Data.Entities&#10;@using Microsoft.EntityFrameworkCore&#10;@inject ApplicationDbContext Db&#10;@inject IDbContextFactory&lt;ApplicationDbContext&gt; DbFactory&#10;@inject NavigationManager Nav&#10;@inject AuthenticationStateProvider Auth&#10;@inject IJSRuntime JS&#10;@inject Services.ImagesCacheService ImagesCache&#10;@inject Services.LayoutService LayoutSvc&#10;&#10;@* Styles moved to app.scss *@&#10;&#10;@if (!authorized)&#10;{&#10;    &lt;div class=&quot;hud&quot;&gt;Forbidden. Invalid token.&lt;/div&gt;&#10;}&#10;else if (layouts is null)&#10;{&#10;    &lt;div class=&quot;hud&quot;&gt;Loading...&lt;/div&gt;&#10;}&#10;else&#10;{&#10;    &lt;script&gt;&#10;        (function(){&#10;            try{&#10;                if (!window.PPSNR_Drag){&#10;                    var s=document.createElement('script');&#10;                    s.src='js/editor-drag.js';&#10;                    s.defer=true;&#10;                    document.head.appendChild(s);&#10;                }&#10;                if (!window.ppsnr){&#10;                    var s2=document.createElement('script');&#10;                    s2.src='js/antiforgery.js';&#10;                    s2.defer=true;&#10;                    document.head.appendChild(s2);&#10;                }&#10;            }catch(e){ console.warn('[edit] script inject failed', e); }&#10;        })();&#10;    &lt;/script&gt;&#10;    &lt;div class=&quot;hud&quot;&gt;&#10;        &lt;b&gt;@pair?.Name&lt;/b&gt; — Drag images to reposition@(editProfile == SlotProfile.Partner ? &quot; (Partner)&quot; : string.Empty). Changes auto-save.&#10;        &lt;button class=&quot;btn btn-sm btn-outline-light ms-2&quot; @onclick=&quot;ResetToDefaultsAsync&quot;&gt;Reset positions&lt;/button&gt;&#10;    &lt;/div&gt;&#10;    &lt;div id=&quot;canvas&quot; data-pair-id=&quot;@pairId&quot;&gt;&#10;        @foreach (var l in layouts)&#10;        {&#10;            @foreach (var s in slots.Where(x =&gt; x.LayoutId == l.Id))&#10;            {&#10;                &lt;div class=&quot;@GetClass(s)&quot; style=&quot;@GetStyle(s)&quot; data-slot-id=&quot;@s.Id.ToString()&quot; data-layout-id=&quot;@l.Id.ToString()&quot; data-z-index=&quot;@GetZIndex(s).ToString()&quot; data-visible=&quot;@GetVisibleAttr(s)&quot; data-image-url=&quot;@GetImageSrc(s)&quot; data-index=&quot;@s.Index.ToString()&quot;&gt;&#10;                    &lt;img src=&quot;@GetImageSrc(s)&quot; draggable=&quot;false&quot; alt=&quot;slot&quot; /&gt;&#10;                    &lt;span class=&quot;resizer nw&quot; data-dir=&quot;nw&quot;&gt;&lt;/span&gt;&#10;                    &lt;span class=&quot;resizer n&quot; data-dir=&quot;n&quot;&gt;&lt;/span&gt;&#10;                    &lt;span class=&quot;resizer ne&quot; data-dir=&quot;ne&quot;&gt;&lt;/span&gt;&#10;                    &lt;span class=&quot;resizer e&quot; data-dir=&quot;e&quot;&gt;&lt;/span&gt;&#10;                    &lt;span class=&quot;resizer se&quot; data-dir=&quot;se&quot;&gt;&lt;/span&gt;&#10;                    &lt;span class=&quot;resizer s&quot; data-dir=&quot;s&quot;&gt;&lt;/span&gt;&#10;                    &lt;span class=&quot;resizer sw&quot; data-dir=&quot;sw&quot;&gt;&lt;/span&gt;&#10;                    &lt;span class=&quot;resizer w&quot; data-dir=&quot;w&quot;&gt;&lt;/span&gt;&#10;                &lt;/div&gt;&#10;            }&#10;        }&#10;    &lt;/div&gt;&#10;}&#10;&#10;@code {&#10;    [Parameter] public Guid pairId { get; set; }&#10;    [Parameter] public Guid token { get; set; }&#10;&#10;    private bool authorized;&#10;    private StreamerPair? pair;&#10;    private List&lt;Layout&gt;? layouts;&#10;    private List&lt;Slot&gt; slots = new();&#10;    private Dictionary&lt;Guid, SlotPlacement&gt; placements = new();&#10;    private HubConnection? hub;&#10;    private const string TransparentPng = &quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAoMBgVqvJi8AAAAASUVORK5CYII=&quot;;&#10;    private SlotProfile editProfile;&#10;    private bool _jsReady; // set after first interactive render completes&#10;    private bool _pendingClearInlineGeometry; // request to run JS clear when next render is ready&#10;    private bool _disposed; // component is being disposed (circuit disconnect/navigation)&#10;&#10;    protected override async Task OnInitializedAsync()&#10;    {&#10;        // Validate token for both owner and partner edit flows&#10;        var link = Db.PairLinks.FirstOrDefault(l =&gt; l.PairId == pairId);&#10;        authorized = false;&#10;        if (link != null &amp;&amp; (link.ExpiresAt == null || link.ExpiresAt &gt; DateTime.UtcNow))&#10;        {&#10;            // Owner edit flow&#10;            if (link.EditToken == token)&#10;            {&#10;                pair = Db.Pairs.FirstOrDefault(p =&gt; p.Id == pairId);&#10;                var state = await Auth.GetAuthenticationStateAsync();&#10;                var userId = state.User?.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value;&#10;                if (pair != null &amp;&amp; !string.IsNullOrEmpty(userId) &amp;&amp; string.Equals(pair.OwnerUserId, userId, StringComparison.Ordinal))&#10;                {&#10;                    authorized = true;&#10;                    editProfile = SlotProfile.Owner;&#10;                }&#10;            }&#10;            // Partner edit flow&#10;            else if (link.PartnerEditToken == token)&#10;            {&#10;                pair = Db.Pairs.FirstOrDefault(p =&gt; p.Id == pairId);&#10;                if (pair != null)&#10;                {&#10;                    authorized = true;&#10;                    editProfile = SlotProfile.Partner;&#10;                }&#10;            }&#10;        }&#10;        if (!authorized) return;&#10;&#10;        layouts = Db.Layouts.Where(l =&gt; l.PairId == pairId).ToList();&#10;        var layoutIds = layouts.Select(l =&gt; l.Id).ToList();&#10;        // Show all slots for both profiles so editors can see the counterpart as well&#10;        // Positions are rendered using the editor's profile placement for every slot (owner or partner)&#10;        slots = Db.Slots.Where(s =&gt; layoutIds.Contains(s.LayoutId))&#10;                        .OrderBy(s =&gt; s.ZIndex)&#10;                        .ToList();&#10;&#10;        // Load placements for the current editor profile across all these slots&#10;        var slotIds = slots.Select(s =&gt; s.Id).ToList();&#10;        placements = Db.SlotPlacements&#10;            .Where(p =&gt; slotIds.Contains(p.SlotId) &amp;&amp; p.Profile == editProfile)&#10;            .ToDictionary(p =&gt; p.SlotId, p =&gt; p);&#10;&#10;        // Normalize any legacy or external ImageUrl values to cached /resources paths so images render&#10;        await NormalizeSlotImagesAsync(slots);&#10;&#10;        // SignalR to see live updates from other editors&#10;        hub = new HubConnectionBuilder().WithUrl(Nav.ToAbsoluteUri(&quot;/hubs/layout&quot;)).WithAutomaticReconnect().Build();&#10;        // Typed envelope handler for forward-compatible messages&#10;        hub.On&lt;PPSNR.Shared.SignalR.SignalRMessageEnvelope&gt;(&quot;Message&quot;, envelope =&gt;&#10;        {&#10;            try&#10;            {&#10;                if (envelope == null) return;&#10;                if (string.Equals(envelope.Type, &quot;SlotUpdated&quot;, StringComparison.OrdinalIgnoreCase) &amp;&amp; envelope.Data.HasValue)&#10;                {&#10;                    var dto = System.Text.Json.JsonSerializer.Deserialize&lt;PPSNR.Shared.SignalR.SlotUpdatedDto&gt;(envelope.Data.Value.GetRawText());&#10;                    if (dto == null) return;&#10;&#10;                    var id = dto.Id;&#10;                    var profile = dto.Profile;&#10;                    var x = dto.X;&#10;                    var y = dto.Y;&#10;                    var z = dto.ZIndex;&#10;                    var vis = dto.Visible;&#10;                    var img = dto.ImageUrl;&#10;                    var add = dto.AdditionalProperties;&#10;                    var width = dto.Width;&#10;                    var height = dto.Height;&#10;&#10;                    var slot = slots.FirstOrDefault(s =&gt; s.Id == id);&#10;                    if (slot != null)&#10;                    {&#10;                        if (profile != null &amp;&amp; (int)editProfile == profile)&#10;                        {&#10;                            if (placements.TryGetValue(slot.Id, out var pl))&#10;                            {&#10;                                if (x.HasValue) pl.X = x.Value;&#10;                                if (y.HasValue) pl.Y = y.Value;&#10;                                if (z.HasValue) pl.ZIndex = z.Value;&#10;                                if (vis.HasValue) pl.Visible = vis.Value;&#10;                                if (width.HasValue) pl.Width = width.Value;&#10;                                if (height.HasValue) pl.Height = height.Value;&#10;                            }&#10;                        }&#10;                        if (dto.ImageUrl != null)&#10;                        {&#10;                            slot.ImageUrl = dto.ImageUrl;&#10;                        }&#10;                        if (dto.AdditionalProperties != null)&#10;                        {&#10;                            slot.AdditionalProperties = dto.AdditionalProperties;&#10;                        }&#10;                        InvokeAsync(StateHasChanged);&#10;                    }&#10;                }&#10;            }&#10;            catch { /* ignore malformed messages */ }&#10;        });&#10;        await hub.StartAsync();&#10;        await hub.SendAsync(&quot;SubscribeToPair&quot;, pairId.ToString());&#10;    }&#10;&#10;    protected override async Task OnAfterRenderAsync(bool firstRender)&#10;    {&#10;        if (firstRender &amp;&amp; authorized)&#10;        {&#10;            var apiBase = editProfile == SlotProfile.Partner ? $&quot;/api/partner/{token}&quot; : &quot;/api&quot;;&#10;            try&#10;            {&#10;                await JS.InvokeVoidAsync(&quot;PPSNR_Drag.init&quot;, apiBase, pairId.ToString());&#10;                _jsReady = true;&#10;            }&#10;            catch (Microsoft.JSInterop.JSDisconnectedException)&#10;            {&#10;                // Circuit not ready; will try again on next render&#10;                _jsReady = false;&#10;            }&#10;            catch (ObjectDisposedException)&#10;            {&#10;                _jsReady = false;&#10;            }&#10;        }&#10;&#10;        // After any render, if we have a pending JS clear request and JS is ready, execute it safely&#10;        if (_pendingClearInlineGeometry &amp;&amp; _jsReady &amp;&amp; !_disposed)&#10;        {&#10;            try&#10;            {&#10;                await JS.InvokeVoidAsync(&quot;PPSNR_Drag.clearInlineGeometry&quot;);&#10;            }&#10;            catch (Microsoft.JSInterop.JSDisconnectedException)&#10;            {&#10;                // Ignore; circuit disconnected&#10;            }&#10;            catch (ObjectDisposedException)&#10;            {&#10;                // Ignore&#10;            }&#10;            finally&#10;            {&#10;                _pendingClearInlineGeometry = false;&#10;            }&#10;        }&#10;    }&#10;    private string GetStyle(Slot s)&#10;    {&#10;        float x = s.X;&#10;        float y = s.Y;&#10;        int z = s.ZIndex;&#10;        int? widthFromPlacement = null;&#10;        int? heightFromPlacement = null;&#10;        if (placements.TryGetValue(s.Id, out var p))&#10;        {&#10;            x = p.X;&#10;            y = p.Y;&#10;            z = p.ZIndex;&#10;            widthFromPlacement = p.Width;&#10;            heightFromPlacement = p.Height;&#10;        }&#10;        var style = $&quot;left:{x}px; top:{y}px; z-index:{z};&quot;;&#10;        // Prefer size from placement when available; fall back to slot additional properties&#10;        int? w = widthFromPlacement;&#10;        int? h = heightFromPlacement;&#10;        if (w == null &amp;&amp; h == null)&#10;        {&#10;            var sz = GetSizeFromAdditional(s);&#10;            w = sz.w; h = sz.h;&#10;        }&#10;        if (!string.IsNullOrEmpty(s.ImageUrl))&#10;        {&#10;            // If no explicit size set, provide a sensible default to avoid huge official artwork&#10;            if (w == null &amp;&amp; h == null)&#10;            {&#10;                w = s.SlotType == SlotType.Pokemon ? 256 : 96;&#10;            }&#10;        }&#10;        else&#10;        {&#10;            // For placeholders ensure a minimum box to drag&#10;            w ??= s.SlotType == SlotType.Pokemon ? 128 : 48;&#10;            h ??= w;&#10;        }&#10;&#10;        if (w != null) style += $&quot; width:{w}px;&quot;;&#10;        if (h != null) style += $&quot; height:{h}px;&quot;;&#10;        return style;&#10;    }&#10;    private string GetClass(Slot s)&#10;    {&#10;        var visible = GetVisible(s);&#10;        return visible ? &quot;drag&quot; : &quot;drag inactive&quot;;&#10;    }&#10;    private bool GetVisible(Slot s)&#10;    {&#10;        if (placements.TryGetValue(s.Id, out var p)) return p.Visible;&#10;        return s.Visible;&#10;    }&#10;    private string GetVisibleAttr(Slot s) =&gt; GetVisible(s) ? &quot;true&quot; : &quot;false&quot;;&#10;    private int GetZIndex(Slot s)&#10;    {&#10;        if (placements.TryGetValue(s.Id, out var p)) return p.ZIndex;&#10;        return s.ZIndex;&#10;    }&#10;    private string GetImageSrc(Slot s) =&gt; string.IsNullOrWhiteSpace(s.ImageUrl) ? TransparentPng : s.ImageUrl!;&#10;    // additional properties are not emitted as a data attribute to avoid large attribute values; JS reads sizes from inline style&#10;&#10;    private async Task NormalizeSlotImagesAsync(IEnumerable&lt;Slot&gt; list)&#10;    {&#10;        var changed = false;&#10;        foreach (var s in list)&#10;        {&#10;            if (!string.IsNullOrWhiteSpace(s.ImageUrl))&#10;            {&#10;                var url = s.ImageUrl!;&#10;                if (!url.StartsWith(&quot;/&quot;))&#10;                {&#10;                    try&#10;                    {&#10;                        var normalized = await ImagesCache.GetCachedImageUrlAsync(url);&#10;                        if (!string.Equals(normalized, url, StringComparison.Ordinal))&#10;                        {&#10;                            s.ImageUrl = normalized;&#10;                            changed = true;&#10;                        }&#10;                    }&#10;                    catch&#10;                    {&#10;                        // ignore normalization failures; keep original so user can fix in selection UI&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        if (changed)&#10;        {&#10;            await Db.SaveChangesAsync();&#10;        }&#10;    }&#10;}&#10;&#10;@code {&#10;    private async Task ResetToDefaultsAsync()&#10;    {&#10;        if (!authorized || pair == null) return;&#10;        try&#10;        {&#10;            // Reset placements for the current editing profile&#10;            await LayoutSvc.ResetPlacementsToDefaultsAsync(pairId, editProfile);&#10;&#10;            // Reload placements from DB for current profile using a fresh context (avoid stale tracked entities)&#10;            await ReloadPlacementsForCurrentProfileAsync();&#10;            // Defer JS to render phase to avoid disconnected/prerender issues&#10;            _pendingClearInlineGeometry = true;&#10;            StateHasChanged();&#10;        }&#10;        catch&#10;        {&#10;            // no-op on failure; UI remains unchanged&#10;        }&#10;    }&#10;&#10;    public async ValueTask DisposeAsync()&#10;    {&#10;        try&#10;        {&#10;            _disposed = true;&#10;            if (hub is not null)&#10;            {&#10;                await hub.DisposeAsync();&#10;            }&#10;        }&#10;        catch { /* ignore */ }&#10;    }&#10;    private async Task ReloadPlacementsForCurrentProfileAsync()&#10;    {&#10;        await using var fresh = await DbFactory.CreateDbContextAsync();&#10;        var slotIds = slots.Select(s =&gt; s.Id).ToList();&#10;        placements = fresh.SlotPlacements&#10;            .Where(p =&gt; slotIds.Contains(p.SlotId) &amp;&amp; p.Profile == editProfile)&#10;            .AsNoTracking()&#10;            .ToDictionary(p =&gt; p.SlotId, p =&gt; p);&#10;    }&#10;    private (int? w, int? h) GetSizeFromAdditional(Slot s)&#10;    {&#10;        try&#10;        {&#10;            if (string.IsNullOrWhiteSpace(s.AdditionalProperties)) return (null, null);&#10;            using var doc = System.Text.Json.JsonDocument.Parse(s.AdditionalProperties);&#10;            var root = doc.RootElement;&#10;            int? w = null, h = null;&#10;            if (TryGetPropertyCI(root, &quot;w&quot;, out var wProp) &amp;&amp; wProp.ValueKind == System.Text.Json.JsonValueKind.Number)&#10;            {&#10;                var v = (int)wProp.GetDouble();&#10;                if (v &gt; 0) w = v;&#10;            }&#10;            if (TryGetPropertyCI(root, &quot;h&quot;, out var hProp) &amp;&amp; hProp.ValueKind == System.Text.Json.JsonValueKind.Number)&#10;            {&#10;                var v = (int)hProp.GetDouble();&#10;                if (v &gt; 0) h = v;&#10;            }&#10;            return (w, h);&#10;        }&#10;        catch&#10;        {&#10;            return (null, null);&#10;        }&#10;    }&#10;    private static bool TryGetPropertyCI(System.Text.Json.JsonElement el, string name, out System.Text.Json.JsonElement prop)&#10;    {&#10;        if (el.TryGetProperty(name, out prop)) return true;&#10;        var camel = LowerFirst(name);&#10;        return el.TryGetProperty(camel, out prop);&#10;    }&#10;    private static bool TryGetValueCI(IDictionary&lt;string, object&gt; dict, string name, out object? value)&#10;    {&#10;        if (dict.TryGetValue(name, out value)) return true;&#10;        var camel = LowerFirst(name);&#10;        return dict.TryGetValue(camel, out value);&#10;    }&#10;    private static string LowerFirst(string s)&#10;        =&gt; string.IsNullOrEmpty(s) ? s : char.ToLowerInvariant(s[0]) + s.Substring(1);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>