<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/PPSNR.Server-AI/Program.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/PPSNR.Server-AI/Program.cs" />
              <option name="originalContent" value="using Microsoft.AspNetCore.Components.Authorization;&#10;using Microsoft.AspNetCore.Identity;&#10;using Microsoft.EntityFrameworkCore;&#10;using PPSNR.Server.Components;&#10;using PPSNR.Server.Components.Account;&#10;using PPSNR.Server.Data;&#10;&#10;var builder = WebApplication.CreateBuilder(args);&#10;&#10;// Add services to the container.&#10;builder.Services.AddRazorComponents()&#10;    .AddInteractiveServerComponents();&#10;&#10;builder.Services.AddCascadingAuthenticationState();&#10;builder.Services.AddScoped&lt;IdentityRedirectManager&gt;();&#10;builder.Services.AddScoped&lt;AuthenticationStateProvider, IdentityRevalidatingAuthenticationStateProvider&gt;();&#10;&#10;builder.Services.AddAuthentication(options =&gt;&#10;    {&#10;        options.DefaultScheme = IdentityConstants.ApplicationScheme;&#10;        options.DefaultSignInScheme = IdentityConstants.ExternalScheme;&#10;    })&#10;    .AddIdentityCookies();&#10;&#10;var connectionString = builder.Configuration.GetConnectionString(&quot;DefaultConnection&quot;) ?? throw new InvalidOperationException(&quot;Connection string 'DefaultConnection' not found.&quot;);&#10;builder.Services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt;&#10;    options.UseSqlite(connectionString));&#10;builder.Services.AddDatabaseDeveloperPageExceptionFilter();&#10;&#10;builder.Services.AddIdentityCore&lt;ApplicationUser&gt;(options =&gt;&#10;    {&#10;        options.SignIn.RequireConfirmedAccount = true;&#10;        options.Stores.SchemaVersion = IdentitySchemaVersions.Version3;&#10;    })&#10;    .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;()&#10;    .AddSignInManager()&#10;    .AddDefaultTokenProviders();&#10;&#10;builder.Services.AddSingleton&lt;IEmailSender&lt;ApplicationUser&gt;, IdentityNoOpEmailSender&gt;();&#10;&#10;var app = builder.Build();&#10;&#10;// Configure the HTTP request pipeline.&#10;if (app.Environment.IsDevelopment())&#10;{&#10;    app.UseMigrationsEndPoint();&#10;}&#10;else&#10;{&#10;    app.UseExceptionHandler(&quot;/Error&quot;, createScopeForErrors: true);&#10;    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.&#10;    app.UseHsts();&#10;}&#10;app.UseStatusCodePagesWithReExecute(&quot;/not-found&quot;, createScopeForStatusCodePages: true);&#10;app.UseHttpsRedirection();&#10;&#10;// Do not register global antiforgery middleware here; validate antiforgery&#10;// explicitly in API POST endpoints. Global registration can force GET pages&#10;// to be validated and cause missing-cookie errors for view pages.&#10;&#10;app.MapStaticAssets();&#10;app.MapRazorComponents&lt;App&gt;()&#10;    .AddInteractiveServerRenderMode();&#10;&#10;// Add additional endpoints required by the Identity /Account Razor components.&#10;app.MapAdditionalIdentityEndpoints();&#10;&#10;app.Run();&#10;" />
              <option name="updatedContent" value="using Microsoft.AspNetCore.Components.Authorization;&#13;&#10;using Microsoft.AspNetCore.Identity;&#13;&#10;using Microsoft.EntityFrameworkCore;&#13;&#10;using PPSNR.Server.Components;&#13;&#10;using PPSNR.Server.Components.Account;&#13;&#10;using PPSNR.Server.Data;&#13;&#10;&#13;&#10;var builder = WebApplication.CreateBuilder(args);&#13;&#10;&#13;&#10;// Add services to the container.&#13;&#10;builder.Services.AddRazorComponents()&#13;&#10;    .AddInteractiveServerComponents();&#13;&#10;&#13;&#10;builder.Services.AddCascadingAuthenticationState();&#13;&#10;builder.Services.AddScoped&lt;IdentityRedirectManager&gt;();&#13;&#10;builder.Services.AddScoped&lt;AuthenticationStateProvider, IdentityRevalidatingAuthenticationStateProvider&gt;();&#13;&#10;&#13;&#10;builder.Services.AddAuthentication(options =&gt;&#13;&#10;    {&#13;&#10;        options.DefaultScheme = IdentityConstants.ApplicationScheme;&#13;&#10;        options.DefaultSignInScheme = IdentityConstants.ExternalScheme;&#13;&#10;    })&#13;&#10;    .AddIdentityCookies();&#13;&#10;&#13;&#10;var connectionString = builder.Configuration.GetConnectionString(&quot;DefaultConnection&quot;) ?? throw new InvalidOperationException(&quot;Connection string 'DefaultConnection' not found.&quot;);&#13;&#10;builder.Services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt;&#13;&#10;    options.UseSqlite(connectionString));&#13;&#10;builder.Services.AddDatabaseDeveloperPageExceptionFilter();&#13;&#10;&#13;&#10;builder.Services.AddIdentityCore&lt;ApplicationUser&gt;(options =&gt;&#13;&#10;    {&#13;&#10;        options.SignIn.RequireConfirmedAccount = true;&#13;&#10;        options.Stores.SchemaVersion = IdentitySchemaVersions.Version3;&#13;&#10;    })&#13;&#10;    .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;()&#13;&#10;    .AddSignInManager()&#13;&#10;    .AddDefaultTokenProviders();&#13;&#10;&#13;&#10;builder.Services.AddSingleton&lt;IEmailSender&lt;ApplicationUser&gt;, IdentityNoOpEmailSender&gt;();&#13;&#10;&#13;&#10;var app = builder.Build();&#13;&#10;&#13;&#10;// Configure the HTTP request pipeline.&#13;&#10;if (app.Environment.IsDevelopment())&#13;&#10;{&#13;&#10;    app.UseMigrationsEndPoint();&#13;&#10;}&#13;&#10;else&#13;&#10;{&#13;&#10;    app.UseExceptionHandler(&quot;/Error&quot;, createScopeForErrors: true);&#13;&#10;    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.&#13;&#10;    app.UseHsts();&#13;&#10;}&#13;&#10;app.UseStatusCodePagesWithReExecute(&quot;/not-found&quot;, createScopeForStatusCodePages: true);&#13;&#10;app.UseHttpsRedirection();&#13;&#10;&#13;&#10;// Do not register global antiforgery middleware here; validate antiforgery&#13;&#10;// explicitly in API POST endpoints. Global registration can force GET pages&#13;&#10;// to be validated and cause missing-cookie errors for view pages.&#13;&#10;&#13;&#10;app.MapStaticAssets();&#13;&#10;app.MapRazorComponents&lt;App&gt;()&#13;&#10;    .AddInteractiveServerRenderMode();&#13;&#10;&#13;&#10;// Add additional endpoints required by the Identity /Account Razor components.&#13;&#10;app.MapAdditionalIdentityEndpoints();&#13;&#10;&#13;&#10;app.Run();" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/PPSNR.Server/Components/Pages/Pair/Index.razor">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/PPSNR.Server/Components/Pages/Pair/Index.razor" />
              <option name="originalContent" value="@page &quot;/pairs&quot;&#10;@attribute [Microsoft.AspNetCore.Mvc.IgnoreAntiforgeryToken]&#10;@using PPSNR.Server2.Data.Entities&#10;@inject NavigationManager Nav&#10;@inject IJSRuntime JS&#10;@inject IDbContextFactory&lt;ApplicationDbContext&gt; DbFactory&#10;@rendermode InteractiveServer&#10;&#10;&lt;h1&gt;Streamer Pairs&lt;/h1&gt;&#10;&#10;&lt;div style=&quot;margin-bottom:8px;&quot;&gt;&#10;    &lt;button @onclick=&quot;CreateSamplePair&quot; disabled=&quot;@busy&quot;&gt;@(busy ? &quot;Creating...&quot; : &quot;Create Sample Pair&quot;)&lt;/button&gt;&#10;    @if (!string.IsNullOrWhiteSpace(status))&#10;    {&#10;        &lt;span style=&quot;margin-left:10px; color:@(statusIsError ? &quot;#c00&quot; : &quot;#090&quot;)&quot;&gt;@status&lt;/span&gt;&#10;    }&#10;    &lt;button style=&quot;margin-left:10px;&quot; @onclick=Reload disabled=&quot;@busy&quot;&gt;Reload&lt;/button&gt;&#10;    &lt;span style=&quot;margin-left:10px; color:#666&quot;&gt;Count: @pairs.Count&lt;/span&gt;&#10;    @if (lastCreatedId != Guid.Empty)&#10;    {&#10;        &lt;span style=&quot;margin-left:10px; color:#666&quot;&gt;Last created: @lastCreatedId&lt;/span&gt;&#10;    }&#10;&lt;/div&gt;&#10;&#10;&lt;ul&gt;&#10;    @foreach (var p in pairs)&#10;    {&#10;        &lt;li&gt;&#10;            &lt;b&gt;@p.Name&lt;/b&gt;&#10;            @if (links.TryGetValue(p.Id, out var link))&#10;            {&#10;                &lt;div&gt;&#10;                    View: &lt;a href=&quot;/@p.Id/view/@link.ViewToken&quot; target=&quot;_blank&quot;&gt;/@p.Id/view/@link.ViewToken&lt;/a&gt;&#10;                &lt;/div&gt;&#10;                &lt;div&gt;&#10;                    Edit: &lt;a href=&quot;/@p.Id/edit/@link.EditToken&quot; target=&quot;_blank&quot;&gt;/@p.Id/edit/@link.EditToken&lt;/a&gt;&#10;                &lt;/div&gt;&#10;            }&#10;            else&#10;            {&#10;                &lt;button @onclick=&quot;(() =&gt; GenerateLinks(p.Id))&quot;&gt;Generate Links&lt;/button&gt;&#10;            }&#10;        &lt;/li&gt;&#10;    }&#10;&lt;/ul&gt;&#10;&#10;@code {&#10;    private List&lt;StreamerPair&gt; pairs = new();&#10;    private Dictionary&lt;Guid, PairLink&gt; links = new();&#10;    private bool busy;&#10;    private string? status;&#10;    private bool statusIsError;&#10;    private Guid lastCreatedId;&#10;&#10;    protected override async Task OnInitializedAsync()&#10;    {&#10;        await Reload();&#10;    }&#10;&#10;    private async Task Reload()&#10;    {&#10;        try&#10;        {&#10;            busy = true;&#10;            await using var db = await DbFactory.CreateDbContextAsync();&#10;            pairs = await db.Pairs.AsNoTracking().OrderByDescending(p =&gt; p.CreatedAt).ToListAsync();&#10;            links.Clear();&#10;            var pairIds = pairs.Select(p =&gt; p.Id).ToList();&#10;            var existingLinks = await db.PairLinks.AsNoTracking().Where(l =&gt; pairIds.Contains(l.PairId)).ToListAsync();&#10;            foreach (var l in existingLinks)&#10;            {&#10;                links[l.PairId] = l;&#10;            }&#10;        }&#10;        finally&#10;        {&#10;            busy = false;&#10;        }&#10;    }&#10;&#10;    private async Task GenerateLinks(Guid id)&#10;    {&#10;        // Perform the POST from the browser so antiforgery cookie and header are included&#10;        // The JS helper will fetch an antiforgery token/cookie pair and then POST with the header&#10;        var dtoText = await JS.InvokeAsync&lt;string&gt;(&quot;ppsnr.postWithAntiforgery&quot;, $&quot;api/pairs/{id}/links&quot;);&#10;        var dto = System.Text.Json.JsonDocument.Parse(dtoText);&#10;        var viewToken = dto.RootElement.GetProperty(&quot;viewToken&quot;).GetGuid();&#10;        var editToken = dto.RootElement.GetProperty(&quot;editToken&quot;).GetGuid();&#10;        links[id] = new PairLink { PairId = id, ViewToken = viewToken, EditToken = editToken };&#10;        StateHasChanged();&#10;    }&#10;&#10;    private async Task CreateSamplePair()&#10;    {&#10;        status = null;&#10;        statusIsError = false;&#10;        busy = true;&#10;        StateHasChanged();&#10;        try&#10;        {&#10;            await using var db = await DbFactory.CreateDbContextAsync();&#10;            var pair = new StreamerPair { Name = $&quot;Pair {DateTime.Now:HHmmss}&quot; };&#10;            db.Pairs.Add(pair);&#10;            var s1 = new Streamer { DisplayName = &quot;Streamer A&quot; };&#10;            var s2 = new Streamer { DisplayName = &quot;Streamer B&quot; };&#10;            db.Streamers.AddRange(s1, s2);&#10;            var l1 = new Layout { Name = &quot;Layout A&quot;, PairId = pair.Id, StreamerId = s1.Id };&#10;            var l2 = new Layout { Name = &quot;Layout B&quot;, PairId = pair.Id, StreamerId = s2.Id };&#10;            db.Layouts.AddRange(l1, l2);&#10;            // Seed 6 Pokemon slots and 16 badge slots for l1&#10;            for (int i = 0; i &lt; 6; i++) db.Slots.Add(new Slot { LayoutId = l1.Id, SlotType = SlotType.Pokemon, Index = i, Visible = false, X = 50 + i * 60, Y = 50, ZIndex = 1 });&#10;            for (int i = 0; i &lt; 16; i++) db.Slots.Add(new Slot { LayoutId = l1.Id, SlotType = SlotType.Badge, Index = i, Visible = i &lt; 8, X = 50 + i * 30, Y = 150, ZIndex = 1 });&#10;            // Same for l2&#10;            for (int i = 0; i &lt; 6; i++) db.Slots.Add(new Slot { LayoutId = l2.Id, SlotType = SlotType.Pokemon, Index = i, Visible = false, X = 50 + i * 60, Y = 250, ZIndex = 1 });&#10;            for (int i = 0; i &lt; 16; i++) db.Slots.Add(new Slot { LayoutId = l2.Id, SlotType = SlotType.Badge, Index = i, Visible = i &lt; 8, X = 50 + i * 30, Y = 350, ZIndex = 1 });&#10;            await db.SaveChangesAsync();&#10;            lastCreatedId = pair.Id;&#10;            status = $&quot;Created pair '{pair.Name}'&quot;;&#10;            await Reload();&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            statusIsError = true;&#10;            status = $&quot;Error: {ex.GetType().Name} - {ex.Message}&quot;;&#10;        }&#10;        finally&#10;        {&#10;            busy = false;&#10;            StateHasChanged();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="@page &quot;/pairs&quot;&#10;@attribute [Microsoft.AspNetCore.Mvc.IgnoreAntiforgeryToken]&#10;@using PPSNR.Server2.Data.Entities&#10;@inject NavigationManager Nav&#10;@inject IJSRuntime JS&#10;@inject IDbContextFactory&lt;ApplicationDbContext&gt; DbFactory&#10;@rendermode InteractiveServer&#10;&#10;&lt;h1&gt;Streamer Pairs&lt;/h1&gt;&#10;&#10;&lt;div style=&quot;margin-bottom:8px;&quot;&gt;&#10;    &lt;button @onclick=&quot;CreateSamplePair&quot; disabled=&quot;@busy&quot;&gt;@(busy ? &quot;Creating...&quot; : &quot;Create Sample Pair&quot;)&lt;/button&gt;&#10;    @if (!string.IsNullOrWhiteSpace(status))&#10;    {&#10;        &lt;span style=&quot;margin-left:10px; color:@(statusIsError ? &quot;#c00&quot; : &quot;#090&quot;)&quot;&gt;@status&lt;/span&gt;&#10;    }&#10;    &lt;button style=&quot;margin-left:10px;&quot; @onclick=Reload disabled=&quot;@busy&quot;&gt;Reload&lt;/button&gt;&#10;    &lt;span style=&quot;margin-left:10px; color:#666&quot;&gt;Count: @pairs.Count&lt;/span&gt;&#10;    @if (lastCreatedId != Guid.Empty)&#10;    {&#10;        &lt;span style=&quot;margin-left:10px; color:#666&quot;&gt;Last created: @lastCreatedId&lt;/span&gt;&#10;    }&#10;&lt;/div&gt;&#10;&#10;&lt;ul&gt;&#10;    @foreach (var p in pairs)&#10;    {&#10;        &lt;li&gt;&#10;            &lt;b&gt;@p.Name&lt;/b&gt;&#10;            @if (links.TryGetValue(p.Id, out var link))&#10;            {&#10;                &lt;div&gt;&#10;                    View: &lt;a href=&quot;/@p.Id/view/@link.ViewToken&quot; target=&quot;_blank&quot;&gt;/@p.Id/view/@link.ViewToken&lt;/a&gt;&#10;                &lt;/div&gt;&#10;                &lt;div&gt;&#10;                    Edit: &lt;a href=&quot;/@p.Id/edit/@link.EditToken&quot; target=&quot;_blank&quot;&gt;/@p.Id/edit/@link.EditToken&lt;/a&gt;&#10;                &lt;/div&gt;&#10;            }&#10;            else&#10;            {&#10;                &lt;button @onclick=&quot;(() =&gt; GenerateLinks(p.Id))&quot;&gt;Generate Links&lt;/button&gt;&#10;            }&#10;        &lt;/li&gt;&#10;    }&#10;&lt;/ul&gt;&#10;&#10;@code {&#10;    private List&lt;StreamerPair&gt; pairs = new();&#10;    private Dictionary&lt;Guid, PairLink&gt; links = new();&#10;    private bool busy;&#10;    private string? status;&#10;    private bool statusIsError;&#10;    private Guid lastCreatedId;&#10;&#10;    protected override async Task OnInitializedAsync()&#10;    {&#10;        await Reload();&#10;    }&#10;&#10;    private async Task Reload()&#10;    {&#10;        try&#10;        {&#10;            busy = true;&#10;            await using var db = await DbFactory.CreateDbContextAsync();&#10;            pairs = await db.Pairs.AsNoTracking().OrderByDescending(p =&gt; p.CreatedAt).ToListAsync();&#10;            links.Clear();&#10;            var pairIds = pairs.Select(p =&gt; p.Id).ToList();&#10;            var existingLinks = await db.PairLinks.AsNoTracking().Where(l =&gt; pairIds.Contains(l.PairId)).ToListAsync();&#10;            foreach (var l in existingLinks)&#10;            {&#10;                links[l.PairId] = l;&#10;            }&#10;        }&#10;        finally&#10;        {&#10;            busy = false;&#10;        }&#10;    }&#10;&#10;    private async Task GenerateLinks(Guid id)&#10;    {&#10;        // Perform the POST from the browser so antiforgery cookie and header are included&#10;        // The JS helper will fetch an antiforgery token/cookie pair and then POST with the header&#10;        var dtoText = await JS.InvokeAsync&lt;string&gt;(&quot;ppsnr.postWithAntiforgery&quot;, $&quot;api/pairs/{id}/links&quot;);&#10;        var dto = System.Text.Json.JsonDocument.Parse(dtoText);&#10;        var viewToken = dto.RootElement.GetProperty(&quot;viewToken&quot;).GetGuid();&#10;        var editToken = dto.RootElement.GetProperty(&quot;editToken&quot;).GetGuid();&#10;        links[id] = new PairLink { PairId = id, ViewToken = viewToken, EditToken = editToken };&#10;        StateHasChanged();&#10;    }&#10;&#10;    private async Task CreateSamplePair()&#10;    {&#10;        status = null;&#10;        statusIsError = false;&#10;        busy = true;&#10;        StateHasChanged();&#10;        try&#10;        {&#10;            await using var db = await DbFactory.CreateDbContextAsync();&#10;            var pair = new StreamerPair { Name = $&quot;Pair {DateTime.Now:HHmmss}&quot; };&#10;            db.Pairs.Add(pair);&#10;            var s1 = new Streamer { DisplayName = &quot;Streamer A&quot; };&#10;            var s2 = new Streamer { DisplayName = &quot;Streamer B&quot; };&#10;            db.Streamers.AddRange(s1, s2);&#10;            var l1 = new Layout { Name = &quot;Layout A&quot;, PairId = pair.Id, StreamerId = s1.Id };&#10;            var l2 = new Layout { Name = &quot;Layout B&quot;, PairId = pair.Id, StreamerId = s2.Id };&#10;            db.Layouts.AddRange(l1, l2);&#10;            // Seed 6 Pokemon slots and 16 badge slots for l1&#10;            for (int i = 0; i &lt; 6; i++) db.Slots.Add(new Slot { LayoutId = l1.Id, SlotType = SlotType.Pokemon, Index = i, Visible = false, X = 50 + i * 60, Y = 50, ZIndex = 1 });&#10;            for (int i = 0; i &lt; 16; i++) db.Slots.Add(new Slot { LayoutId = l1.Id, SlotType = SlotType.Badge, Index = i, Visible = i &lt; 8, X = 50 + i * 30, Y = 150, ZIndex = 1 });&#10;            // Same for l2&#10;            for (int i = 0; i &lt; 6; i++) db.Slots.Add(new Slot { LayoutId = l2.Id, SlotType = SlotType.Pokemon, Index = i, Visible = false, X = 50 + i * 60, Y = 250, ZIndex = 1 });&#10;            for (int i = 0; i &lt; 16; i++) db.Slots.Add(new Slot { LayoutId = l2.Id, SlotType = SlotType.Badge, Index = i, Visible = i &lt; 8, X = 50 + i * 30, Y = 350, ZIndex = 1 });&#10;            await db.SaveChangesAsync();&#10;            lastCreatedId = pair.Id;&#10;            status = $&quot;Created pair '{pair.Name}'&quot;;&#10;            await Reload();&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            statusIsError = true;&#10;            status = $&quot;Error: {ex.GetType().Name} - {ex.Message}&quot;;&#10;        }&#10;        finally&#10;        {&#10;            busy = false;&#10;            StateHasChanged();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/PPSNR.Server/Controllers/Api/LayoutController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/PPSNR.Server/Controllers/Api/LayoutController.cs" />
              <option name="originalContent" value="using Microsoft.AspNetCore.Authorization;&#10;using Microsoft.AspNetCore.Mvc;&#10;using Microsoft.EntityFrameworkCore;&#10;using PPSNR.Server2.Data;&#10;using PPSNR.Server2.Data.Entities;&#10;using PPSNR.Server2.Services;&#10;&#10;namespace PPSNR.Server2.Controllers.Api;&#10;&#10;[ApiController]&#10;[Route(&quot;api&quot;)] &#10;public class LayoutController : ControllerBase&#10;{&#10;    private readonly ApplicationDbContext _db;&#10;    private readonly LayoutService _layoutService;&#10;&#10;    public LayoutController(ApplicationDbContext db, LayoutService layoutService)&#10;    {&#10;        _db = db;&#10;        _layoutService = layoutService;&#10;    }&#10;&#10;    [HttpPost(&quot;pairs/{pairId:guid}/links&quot;)]&#10;    public async Task&lt;IActionResult&gt; CreateOrRotateLinks(Guid pairId, [FromServices] Microsoft.AspNetCore.Antiforgery.IAntiforgery antiforgery)&#10;    {&#10;        // Validate antiforgery token explicitly for this POST endpoint&#10;        await antiforgery.ValidateRequestAsync(HttpContext);&#10;        var pair = await _db.Pairs.FindAsync(pairId);&#10;        if (pair == null) return NotFound();&#10;        var link = await _layoutService.CreateOrRotatePairLinkAsync(pairId);&#10;        return Ok(new { link.ViewToken, link.EditToken });&#10;    }&#10;&#10;    // Endpoint to issue and return an antiforgery request token and set the antiforgery cookie in the browser.&#10;    // The browser must call this (via fetch) so the cookie is stored client-side.&#10;    [HttpGet(&quot;antiforgery/token&quot;)]&#10;    [AllowAnonymous]&#10;    public IActionResult GetAntiforgeryToken([FromServices] Microsoft.AspNetCore.Antiforgery.IAntiforgery antiforgery)&#10;    {&#10;        var tokens = antiforgery.GetAndStoreTokens(HttpContext);&#10;        var headerName = tokens.HeaderName ?? &quot;RequestVerificationToken&quot;;&#10;        return Ok(new { token = tokens.RequestToken, headerName });&#10;    }&#10;&#10;    [HttpPost(&quot;pairs/{pairId:guid}/layouts/{layoutId:guid}/slots/{slotId:guid}&quot;)]&#10;    [Authorize]&#10;    public async Task&lt;IActionResult&gt; UpdateSlot(Guid pairId, Guid layoutId, Guid slotId, [FromBody] Slot incoming, [FromServices] Microsoft.AspNetCore.Antiforgery.IAntiforgery antiforgery)&#10;     {&#10;        await antiforgery.ValidateRequestAsync(HttpContext);&#10;         if (slotId != incoming.Id) return BadRequest();&#10;         var layout = await _db.Layouts.FirstOrDefaultAsync(l =&gt; l.Id == layoutId &amp;&amp; l.PairId == pairId);&#10;         if (layout == null) return NotFound();&#10;&#10;         var updated = await _layoutService.UpdateSlotAsync(pairId, incoming);&#10;         if (updated == null) return NotFound();&#10;         return Ok(updated);&#10;     }&#10; }" />
              <option name="updatedContent" value="using Microsoft.AspNetCore.Authorization;&#10;using Microsoft.AspNetCore.Mvc;&#10;using Microsoft.EntityFrameworkCore;&#10;using PPSNR.Server2.Data;&#10;using PPSNR.Server2.Data.Entities;&#10;using PPSNR.Server2.Services;&#10;&#10;namespace PPSNR.Server2.Controllers.Api;&#10;&#10;[ApiController]&#10;[Route(&quot;api&quot;)] &#10;public class LayoutController : ControllerBase&#10;{&#10;    private readonly ApplicationDbContext _db;&#10;    private readonly LayoutService _layoutService;&#10;&#10;    public LayoutController(ApplicationDbContext db, LayoutService layoutService)&#10;    {&#10;        _db = db;&#10;        _layoutService = layoutService;&#10;    }&#10;&#10;    [HttpPost(&quot;pairs/{pairId:guid}/links&quot;)]&#10;    public async Task&lt;IActionResult&gt; CreateOrRotateLinks(Guid pairId, [FromServices] Microsoft.AspNetCore.Antiforgery.IAntiforgery antiforgery)&#10;    {&#10;        // Validate antiforgery token explicitly for this POST endpoint&#10;        await antiforgery.ValidateRequestAsync(HttpContext);&#10;        var pair = await _db.Pairs.FindAsync(pairId);&#10;        if (pair == null) return NotFound();&#10;        var link = await _layoutService.CreateOrRotatePairLinkAsync(pairId);&#10;        return Ok(new { link.ViewToken, link.EditToken });&#10;    }&#10;&#10;    // Endpoint to issue and return an antiforgery request token and set the antiforgery cookie in the browser.&#10;    // The browser must call this (via fetch) so the cookie is stored client-side.&#10;    [HttpGet(&quot;antiforgery/token&quot;)]&#10;    [AllowAnonymous]&#10;    public IActionResult GetAntiforgeryToken([FromServices] Microsoft.AspNetCore.Antiforgery.IAntiforgery antiforgery)&#10;    {&#10;        var tokens = antiforgery.GetAndStoreTokens(HttpContext);&#10;        var headerName = tokens.HeaderName ?? &quot;RequestVerificationToken&quot;;&#10;        return Ok(new { token = tokens.RequestToken, headerName });&#10;    }&#10;&#10;    [HttpPost(&quot;pairs/{pairId:guid}/layouts/{layoutId:guid}/slots/{slotId:guid}&quot;)]&#10;    [Authorize]&#10;    public async Task&lt;IActionResult&gt; UpdateSlot(Guid pairId, Guid layoutId, Guid slotId, [FromBody] Slot incoming, [FromServices] Microsoft.AspNetCore.Antiforgery.IAntiforgery antiforgery)&#10;     {&#10;        await antiforgery.ValidateRequestAsync(HttpContext);&#10;         if (slotId != incoming.Id) return BadRequest();&#10;         var layout = await _db.Layouts.FirstOrDefaultAsync(l =&gt; l.Id == layoutId &amp;&amp; l.PairId == pairId);&#10;         if (layout == null) return NotFound();&#10;&#10;         var updated = await _layoutService.UpdateSlotAsync(pairId, incoming);&#10;         if (updated == null) return NotFound();&#10;         return Ok(updated);&#10;     }&#10; }" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/PPSNR.Tests/LayoutLinksTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/PPSNR.Tests/LayoutLinksTests.cs" />
              <option name="originalContent" value="using System;&#10;using System.Linq;&#10;using System.Net;&#10;using System.Net.Http;&#10;using System.Text.Json;&#10;using System.Threading.Tasks;&#10;using FluentAssertions;&#10;using FluentAssertions.Execution;&#10;using Microsoft.AspNetCore.Mvc.Testing;&#10;using Microsoft.Extensions.DependencyInjection;&#10;using NUnit.Framework;&#10;using PPSNR.Server2.Data;&#10;using PPSNR.Server2.Data.Entities;&#10;&#10;namespace PPSNR.Tests;&#10;&#10;public class LayoutLinksTests&#10;{&#10;    private TestWebApplicationFactory _factory;&#10;    private HttpClient _client;&#10;&#10;    [SetUp]&#10;    public void Setup()&#10;    {&#10;        _factory = new TestWebApplicationFactory();&#10;        _client = _factory.CreateClient(new WebApplicationFactoryClientOptions&#10;        {&#10;            AllowAutoRedirect = false,&#10;            HandleCookies = true&#10;        });&#10;&#10;        // Seed a StreamerPair into the test DB&#10;        using var scope = _factory.Services.CreateScope();&#10;        var db = scope.ServiceProvider.GetRequiredService&lt;ApplicationDbContext&gt;();&#10;        var pair = new StreamerPair { Name = &quot;Test Pair&quot; };&#10;        db.Pairs.Add(pair);&#10;        db.SaveChanges();&#10;    }&#10;&#10;    [TearDown]&#10;    public void Teardown()&#10;    {&#10;        _client.Dispose();&#10;        _factory.Dispose();&#10;    }&#10;&#10;    [Test]&#10;    public async Task CreateOrRotateLinks_ReturnsTokensAndSaves()&#10;    {&#10;        // Get the seeded pair&#10;        Guid pairId;&#10;        using (var scope = _factory.Services.CreateScope())&#10;        {&#10;            var db = scope.ServiceProvider.GetRequiredService&lt;ApplicationDbContext&gt;();&#10;            pairId = db.Pairs.Select(p =&gt; p.Id).First();&#10;        }&#10;&#10;        // Fetch antiforgery token and store cookie&#10;        var tokenResp = await _client.GetAsync(&quot;/api/antiforgery/token&quot;);&#10;        tokenResp.StatusCode.Should().Be(HttpStatusCode.OK);&#10;        var tokenJson = JsonDocument.Parse(await tokenResp.Content.ReadAsStringAsync());&#10;        tokenJson.RootElement.TryGetProperty(&quot;token&quot;, out var tokenEl).Should().BeTrue();&#10;        tokenJson.RootElement.TryGetProperty(&quot;headerName&quot;, out var headerEl).Should().BeTrue();&#10;        var headerName = headerEl.GetString() ?? &quot;RequestVerificationToken&quot;;&#10;        var token = tokenEl.GetString();&#10;&#10;        // Prepare POST request with antiforgery header&#10;        var request = new HttpRequestMessage(HttpMethod.Post, $&quot;/api/pairs/{pairId}/links&quot;);&#10;        if (!string.IsNullOrEmpty(token)) request.Headers.Add(headerName, token);&#10;        var resp = await _client.SendAsync(request);&#10;&#10;        using var assertionScope = new AssertionScope();&#10;        if (resp.StatusCode != HttpStatusCode.OK)&#10;        {&#10;            var body = await resp.Content.ReadAsStringAsync();&#10;            // Help debugging - fail with server response body&#10;            Assert.Fail($&quot;Expected 200 OK but got {(int)resp.StatusCode} {resp.StatusCode}. Response body: {body}&quot;);&#10;        }&#10;&#10;        resp.StatusCode.Should().Be(HttpStatusCode.OK);&#10;&#10;        var json = JsonDocument.Parse(await resp.Content.ReadAsStringAsync());&#10;        json.RootElement.TryGetProperty(&quot;viewToken&quot;, out var viewEl).Should().BeTrue();&#10;        json.RootElement.TryGetProperty(&quot;editToken&quot;, out var editEl).Should().BeTrue();&#10;        Guid.TryParse(viewEl.GetString(), out var _).Should().BeTrue();&#10;        Guid.TryParse(editEl.GetString(), out var _).Should().BeTrue();&#10;&#10;        // Verify DB persisted&#10;        using var scope2 = _factory.Services.CreateScope();&#10;        var db2 = scope2.ServiceProvider.GetRequiredService&lt;ApplicationDbContext&gt;();&#10;        var link = db2.PairLinks.FirstOrDefault(pl =&gt; pl.PairId == pairId);&#10;        link.Should().NotBeNull();&#10;&#10;        if (link != null)&#10;        {&#10;            link.ViewToken.Should().NotBeEmpty();&#10;            link.EditToken.Should().NotBeEmpty();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Linq;&#10;using System.Net;&#10;using System.Net.Http;&#10;using System.Text.Json;&#10;using System.Threading.Tasks;&#10;using FluentAssertions;&#10;using FluentAssertions.Execution;&#10;using Microsoft.AspNetCore.Mvc.Testing;&#10;using Microsoft.Extensions.DependencyInjection;&#10;using NUnit.Framework;&#10;using PPSNR.Server2.Data;&#10;using PPSNR.Server2.Data.Entities;&#10;&#10;namespace PPSNR.Tests;&#10;&#10;public class LayoutLinksTests&#10;{&#10;    private TestWebApplicationFactory _factory;&#10;    private HttpClient _client;&#10;&#10;    [SetUp]&#10;    public void Setup()&#10;    {&#10;        _factory = new TestWebApplicationFactory();&#10;        _client = _factory.CreateClient(new WebApplicationFactoryClientOptions&#10;        {&#10;            AllowAutoRedirect = false,&#10;            HandleCookies = true&#10;        });&#10;&#10;        // Seed a StreamerPair into the test DB&#10;        using var scope = _factory.Services.CreateScope();&#10;        var db = scope.ServiceProvider.GetRequiredService&lt;ApplicationDbContext&gt;();&#10;        var pair = new StreamerPair { Name = &quot;Test Pair&quot; };&#10;        db.Pairs.Add(pair);&#10;        db.SaveChanges();&#10;    }&#10;&#10;    [TearDown]&#10;    public void Teardown()&#10;    {&#10;        _client.Dispose();&#10;        _factory.Dispose();&#10;    }&#10;&#10;    [Test]&#10;    public async Task CreateOrRotateLinks_ReturnsTokensAndSaves()&#10;    {&#10;        // Get the seeded pair&#10;        Guid pairId;&#10;        using (var scope = _factory.Services.CreateScope())&#10;        {&#10;            var db = scope.ServiceProvider.GetRequiredService&lt;ApplicationDbContext&gt;();&#10;            pairId = db.Pairs.Select(p =&gt; p.Id).First();&#10;        }&#10;&#10;        // Fetch antiforgery token and store cookie&#10;        var tokenResp = await _client.GetAsync(&quot;/api/antiforgery/token&quot;);&#10;        tokenResp.StatusCode.Should().Be(HttpStatusCode.OK);&#10;        var tokenJson = JsonDocument.Parse(await tokenResp.Content.ReadAsStringAsync());&#10;        tokenJson.RootElement.TryGetProperty(&quot;token&quot;, out var tokenEl).Should().BeTrue();&#10;        tokenJson.RootElement.TryGetProperty(&quot;headerName&quot;, out var headerEl).Should().BeTrue();&#10;        var headerName = headerEl.GetString() ?? &quot;RequestVerificationToken&quot;;&#10;        var token = tokenEl.GetString();&#10;&#10;        // Prepare POST request with antiforgery header&#10;        var request = new HttpRequestMessage(HttpMethod.Post, $&quot;/api/pairs/{pairId}/links&quot;);&#10;        if (!string.IsNullOrEmpty(token)) request.Headers.Add(headerName, token);&#10;        var resp = await _client.SendAsync(request);&#10;&#10;        using var assertionScope = new AssertionScope();&#10;        if (resp.StatusCode != HttpStatusCode.OK)&#10;        {&#10;            var body = await resp.Content.ReadAsStringAsync();&#10;            // Help debugging - fail with server response body&#10;            Assert.Fail($&quot;Expected 200 OK but got {(int)resp.StatusCode} {resp.StatusCode}. Response body: {body}&quot;);&#10;        }&#10;&#10;        resp.StatusCode.Should().Be(HttpStatusCode.OK);&#10;&#10;        var json = JsonDocument.Parse(await resp.Content.ReadAsStringAsync());&#10;        json.RootElement.TryGetProperty(&quot;viewToken&quot;, out var viewEl).Should().BeTrue();&#10;        json.RootElement.TryGetProperty(&quot;editToken&quot;, out var editEl).Should().BeTrue();&#10;        Guid.TryParse(viewEl.GetString(), out var _).Should().BeTrue();&#10;        Guid.TryParse(editEl.GetString(), out var _).Should().BeTrue();&#10;&#10;        // Verify DB persisted&#10;        using var scope2 = _factory.Services.CreateScope();&#10;        var db2 = scope2.ServiceProvider.GetRequiredService&lt;ApplicationDbContext&gt;();&#10;        var link = db2.PairLinks.FirstOrDefault(pl =&gt; pl.PairId == pairId);&#10;        link.Should().NotBeNull();&#10;&#10;        if (link != null)&#10;        {&#10;            link.ViewToken.Should().NotBeEmpty();&#10;            link.EditToken.Should().NotBeEmpty();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>